# テスト仕様書_ログイン_01 (アプリケーション全体保護版)

## 1. テスト概要

### 1.1 目的
実装計画_ログイン_03で設計されたFastAPIアプリケーション全体保護認証システムの品質保証を行う。
ミドルウェアベースの認証機能、JWT認証、メモリ内ユーザー管理の動作を包括的に検証する。

### 1.2 テスト対象システム
- **システム名**: FastAPI Azure OpenAI議事録生成システム
- **認証方式**: JWTトークンベース + ミドルウェア
- **保護範囲**: アプリケーション全体（`http://localhost:8000/*`）
- **ユーザー管理**: メモリ内Python辞書
- **除外パス**: `/api/v1/auth/login`, `/api/v1/auth/register`, `/health`

### 1.3 テスト範囲
- **ユニットテスト**: 個別モジュールの機能検証
- **統合テスト**: モジュール間連携の検証
- **ミドルウェアテスト**: 認証ミドルウェアの動作検証
- **エンドツーエンドテスト**: 全体フローの検証
- **セキュリティテスト**: 認証・認可の脆弱性検証
- **パフォーマンステスト**: 認証処理の性能検証

## 2. テスト環境

### 2.1 テスト環境構成
```
テスト環境:
├── Python 3.12+
├── FastAPI
├── pytest
├── pytest-asyncio
├── httpx (TestClient)
├── メモリ内データベース
└── モックAzure OpenAI API
```

### 2.2 テストデータ
```python
# テスト用ユーザーデータ
TEST_USERS = {
    "valid_user": {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123"
    },
    "admin_user": {
        "username": "admin",
        "email": "admin@example.com", 
        "password": "adminpassword123"
    },
    "invalid_user": {
        "username": "invalid",
        "email": "invalid@example.com",
        "password": "wrongpassword"
    }
}

# テスト用JWTトークン
TEST_TOKENS = {
    "valid_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    "expired_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    "invalid_token": "invalid.jwt.token"
}
```

## 3. ユニットテスト仕様

### 3.1 認証ユーティリティテスト (src/modules/auth.py)

#### 3.1.1 パスワードハッシュ化テスト
```python
# tests/unit/test_auth_utils.py
import pytest
from src.modules.auth import get_password_hash, verify_password

class TestPasswordHashing:
    def test_password_hash_generation(self):
        """パスワードハッシュ化の正常動作テスト"""
        password = "testpassword123"
        hashed = get_password_hash(password)
        
        assert hashed is not None
        assert hashed != password
        assert len(hashed) > 0
        assert isinstance(hashed, str)
    
    def test_password_verification_success(self):
        """パスワード検証成功テスト"""
        password = "testpassword123"
        hashed = get_password_hash(password)
        
        assert verify_password(password, hashed) is True
    
    def test_password_verification_failure(self):
        """パスワード検証失敗テスト"""
        password = "testpassword123"
        wrong_password = "wrongpassword"
        hashed = get_password_hash(password)
        
        assert verify_password(wrong_password, hashed) is False
    
    def test_empty_password_handling(self):
        """空パスワードの処理テスト"""
        with pytest.raises(ValueError):
            get_password_hash("")
    
    def test_unicode_password_support(self):
        """Unicode文字を含むパスワードのテスト"""
        password = "パスワード123"
        hashed = get_password_hash(password)
        
        assert verify_password(password, hashed) is True
```

#### 3.1.2 JWTトークンテスト
```python
class TestJWTOperations:
    def test_token_creation(self):
        """JWTトークン生成テスト"""
        data = {"sub": "testuser"}
        token = create_access_token(data)
        
        assert token is not None
        assert isinstance(token, str)
        assert len(token.split('.')) == 3  # JWT形式確認
    
    def test_token_verification_success(self):
        """JWTトークン検証成功テスト"""
        data = {"sub": "testuser"}
        token = create_access_token(data)
        
        payload = verify_access_token(token)
        assert payload["sub"] == "testuser"
        assert "exp" in payload
    
    def test_token_verification_failure(self):
        """JWTトークン検証失敗テスト"""
        invalid_token = "invalid.jwt.token"
        
        with pytest.raises(JWTError):
            verify_access_token(invalid_token)
    
    def test_expired_token_handling(self):
        """期限切れトークンの処理テスト"""
        # 過去の時刻でトークン生成（モック使用）
        with patch('src.modules.auth.datetime') as mock_datetime:
            mock_datetime.utcnow.return_value = datetime(2020, 1, 1)
            token = create_access_token({"sub": "testuser"})
        
        with pytest.raises(JWTError, match="Token has expired"):
            verify_access_token(token)
```

### 3.2 ユーザーストアテスト (src/modules/user_store.py)

#### 3.2.1 ユーザー管理テスト
```python
# tests/unit/test_user_store.py
import pytest
from src.modules.user_store import UserStore

class TestUserStore:
    def setup_method(self):
        """各テスト前の初期化"""
        self.user_store = UserStore()
    
    def test_user_creation(self):
        """ユーザー作成テスト"""
        user = self.user_store.create_user(
            "testuser", 
            "test@example.com", 
            "hashedpassword"
        )
        
        assert user["username"] == "testuser"
        assert user["email"] == "test@example.com"
        assert user["is_active"] is True
        assert "created_at" in user
        assert "hashed_password" not in user  # レスポンスに含まれない
    
    def test_duplicate_user_creation(self):
        """重複ユーザー作成テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        with pytest.raises(ValueError, match="Username already exists"):
            self.user_store.create_user("testuser", "other@example.com", "hash")
    
    def test_user_retrieval_by_username(self):
        """ユーザー名による取得テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        user = self.user_store.get_user_by_username("testuser")
        assert user is not None
        assert user["username"] == "testuser"
        
        non_user = self.user_store.get_user_by_username("nonexistent")
        assert non_user is None
    
    def test_user_retrieval_by_email(self):
        """メールアドレスによる取得テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        user = self.user_store.get_user_by_email("test@example.com")
        assert user is not None
        assert user["email"] == "test@example.com"
    
    def test_user_deletion(self):
        """ユーザー削除テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        result = self.user_store.delete_user("testuser")
        assert result is True
        
        user = self.user_store.get_user_by_username("testuser")
        assert user is None
    
    def test_user_update(self):
        """ユーザー更新テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        updated_user = self.user_store.update_user(
            "testuser", 
            email="newemail@example.com",
            is_active=False
        )
        
        assert updated_user["email"] == "newemail@example.com"
        assert updated_user["is_active"] is False
```

### 3.3 認証ミドルウェアテスト (src/middleware/auth.py)

#### 3.3.1 ミドルウェア動作テスト
```python
# tests/unit/test_auth_middleware.py
import pytest
from unittest.mock import Mock, AsyncMock
from fastapi import Request
from src.middleware.auth import AuthenticationMiddleware

class TestAuthenticationMiddleware:
    def setup_method(self):
        """各テスト前の初期化"""
        self.app = Mock()
        self.middleware = AuthenticationMiddleware(self.app)
    
    @pytest.mark.asyncio
    async def test_excluded_path_bypass(self):
        """除外パスのバイパステスト"""
        request = Mock(spec=Request)
        request.url.path = "/api/v1/auth/login"
        call_next = AsyncMock(return_value="response")
        
        result = await self.middleware.dispatch(request, call_next)
        
        call_next.assert_called_once_with(request)
        assert result == "response"
    
    @pytest.mark.asyncio
    async def test_missing_authorization_header(self):
        """Authorizationヘッダー不足テスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.headers.get.return_value = None
        call_next = AsyncMock()
        
        result = await self.middleware.dispatch(request, call_next)
        
        call_next.assert_not_called()
        assert result.status_code == 401
        assert "Authorization header required" in str(result.body)
    
    @pytest.mark.asyncio
    async def test_invalid_authorization_format(self):
        """無効なAuthorizationフォーマットテスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.headers.get.return_value = "InvalidFormat"
        call_next = AsyncMock()
        
        result = await self.middleware.dispatch(request, call_next)
        
        call_next.assert_not_called()
        assert result.status_code == 401
        assert "Invalid authorization header format" in str(result.body)
    
    @pytest.mark.asyncio
    async def test_valid_token_processing(self):
        """有効トークンの処理テスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.headers.get.return_value = "Bearer valid_jwt_token"
        request.state = Mock()
        call_next = AsyncMock(return_value="success_response")
        
        with patch('src.middleware.auth.verify_access_token') as mock_verify:
            mock_verify.return_value = {"sub": "testuser"}
            
            result = await self.middleware.dispatch(request, call_next)
            
            mock_verify.assert_called_once_with("valid_jwt_token")
            call_next.assert_called_once_with(request)
            assert request.state.current_user == "testuser"
            assert result == "success_response"
    
    @pytest.mark.asyncio
    async def test_invalid_token_handling(self):
        """無効トークンの処理テスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.headers.get.return_value = "Bearer invalid_token"
        call_next = AsyncMock()
        
        with patch('src.middleware.auth.verify_access_token') as mock_verify:
            mock_verify.side_effect = JWTError("Invalid token")
            
            result = await self.middleware.dispatch(request, call_next)
            
            call_next.assert_not_called()
            assert result.status_code == 401
            assert "Invalid or expired token" in str(result.body)
```

## 4. 統合テスト仕様

### 4.1 認証フローテスト

#### 4.1.1 ユーザー登録・ログインフロー
```python
# tests/integration/test_auth_flow.py
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestAuthenticationFlow:
    def test_user_registration_and_login(self):
        """ユーザー登録からログインまでのフローテスト"""
        # ユーザー登録
        register_data = {
            "username": "flowtest",
            "email": "flowtest@example.com",
            "password": "flowtestpass123"
        }
        
        register_response = client.post("/api/v1/auth/register", json=register_data)
        assert register_response.status_code == 200
        
        user_data = register_response.json()
        assert user_data["username"] == "flowtest"
        assert user_data["email"] == "flowtest@example.com"
        assert user_data["is_active"] is True
        
        # ログイン
        login_data = {
            "username": "flowtest",
            "password": "flowtestpass123"
        }
        
        login_response = client.post("/api/v1/auth/login", data=login_data)
        assert login_response.status_code == 200
        
        token_data = login_response.json()
        assert "access_token" in token_data
        assert token_data["token_type"] == "bearer"
        
        return token_data["access_token"]
    
    def test_protected_endpoint_access_with_token(self):
        """認証トークンを使用した保護エンドポイントアクセステスト"""
        token = self.test_user_registration_and_login()
        
        # 保護されたエンドポイントアクセス
        headers = {"Authorization": f"Bearer {token}"}
        
        # ルートエンドポイント
        root_response = client.get("/", headers=headers)
        assert root_response.status_code == 200
        
        # 議事録生成エンドポイント
        minutes_data = {
            "meeting_title": "テスト会議",
            "meeting_date": "2025-07-15T10:00:00",
            "participants": ["テスト太郎", "テスト花子"],
            "transcript_text": "テスト会議の内容です。"
        }
        
        minutes_response = client.post("/api/v1/minutes/generate", 
                                     json=minutes_data, headers=headers)
        assert minutes_response.status_code == 200
    
    def test_duplicate_registration_prevention(self):
        """重複登録防止テスト"""
        user_data = {
            "username": "duplicate",
            "email": "duplicate@example.com",
            "password": "password123"
        }
        
        # 初回登録
        first_response = client.post("/api/v1/auth/register", json=user_data)
        assert first_response.status_code == 200
        
        # 重複登録試行
        second_response = client.post("/api/v1/auth/register", json=user_data)
        assert second_response.status_code == 400
        assert "already registered" in second_response.json()["detail"]
```

#### 4.1.2 認証失敗フロー
```python
class TestAuthenticationFailures:
    def test_invalid_login_credentials(self):
        """無効な認証情報でのログインテスト"""
        # 存在しないユーザー
        invalid_data = {
            "username": "nonexistent",
            "password": "anypassword"
        }
        
        response = client.post("/api/v1/auth/login", data=invalid_data)
        assert response.status_code == 401
        assert "Incorrect username or password" in response.json()["detail"]
    
    def test_wrong_password_login(self):
        """間違ったパスワードでのログインテスト"""
        # ユーザー登録
        register_data = {
            "username": "wrongpass",
            "email": "wrongpass@example.com",
            "password": "correctpass123"
        }
        client.post("/api/v1/auth/register", json=register_data)
        
        # 間違ったパスワードでログイン
        login_data = {
            "username": "wrongpass",
            "password": "wrongpassword"
        }
        
        response = client.post("/api/v1/auth/login", data=login_data)
        assert response.status_code == 401
        assert "Incorrect username or password" in response.json()["detail"]
```

### 4.2 ミドルウェア統合テスト

#### 4.2.1 アプリケーション全体保護テスト
```python
# tests/integration/test_middleware_integration.py
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestMiddlewareIntegration:
    def test_all_endpoints_require_authentication(self):
        """全エンドポイントの認証必須テスト"""
        protected_endpoints = [
            "/",
            "/api/v1/minutes/generate",
            "/docs",
            "/redoc"
        ]
        
        for endpoint in protected_endpoints:
            response = client.get(endpoint)
            assert response.status_code == 401, f"Endpoint {endpoint} should require authentication"
            assert "Authorization header required" in response.json()["detail"]
    
    def test_excluded_paths_accessibility(self):
        """除外パスのアクセス可能性テスト"""
        excluded_endpoints = [
            "/api/v1/auth/login",
            "/api/v1/auth/register", 
            "/health"
        ]
        
        for endpoint in excluded_endpoints:
            if endpoint == "/health":
                response = client.get(endpoint)
                assert response.status_code == 200, f"Endpoint {endpoint} should be accessible without auth"
            else:
                # 認証エンドポイントは適切なデータが必要
                response = client.get(endpoint)
                assert response.status_code != 401, f"Endpoint {endpoint} should not require auth header"
    
    def test_middleware_order_with_cors(self):
        """CORSミドルウェアとの順序テスト"""
        # OPTIONSリクエスト（CORS preflight）
        response = client.options("/", headers={
            "Origin": "http://localhost:3000",
            "Access-Control-Request-Method": "GET"
        })
        
        # CORSが先に処理されるため、認証エラーではなくCORS応答
        assert "access-control-allow-origin" in response.headers
    
    def test_request_state_user_injection(self):
        """リクエスト状態へのユーザー情報注入テスト"""
        # ユーザー登録とログイン
        register_data = {
            "username": "statetest",
            "email": "statetest@example.com",
            "password": "statetest123"
        }
        client.post("/api/v1/auth/register", json=register_data)
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "statetest",
            "password": "statetest123"
        })
        token = login_response.json()["access_token"]
        
        # 保護されたエンドポイントでユーザー情報確認
        headers = {"Authorization": f"Bearer {token}"}
        response = client.get("/", headers=headers)
        
        assert response.status_code == 200
        # レスポンスでユーザー情報が利用可能であることを確認
        # (実際の実装では、エンドポイントでrequest.state.current_userを使用)
```

## 5. エンドツーエンドテスト仕様

### 5.1 完全なユーザージャーニーテスト

#### 5.1.1 議事録生成フローテスト
```python
# tests/e2e/test_complete_flow.py
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestCompleteUserJourney:
    def test_complete_meeting_minutes_flow(self):
        """完全な議事録生成フローテスト"""
        # Step 1: ユーザー登録
        register_data = {
            "username": "meetinguser",
            "email": "meeting@example.com",
            "password": "meetingpass123"
        }
        
        register_response = client.post("/api/v1/auth/register", json=register_data)
        assert register_response.status_code == 200
        
        # Step 2: ログイン
        login_response = client.post("/api/v1/auth/login", data={
            "username": "meetinguser",
            "password": "meetingpass123"
        })
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
        
        # Step 3: 認証ヘッダー設定
        headers = {"Authorization": f"Bearer {token}"}
        
        # Step 4: アプリケーション状態確認
        root_response = client.get("/", headers=headers)
        assert root_response.status_code == 200
        assert "auth" in root_response.json()
        
        # Step 5: 議事録生成実行
        meeting_data = {
            "meeting_title": "プロジェクト進捗会議",
            "meeting_date": "2025-07-15T14:00:00",
            "participants": ["田中部長", "佐藤主任", "鈴木さん"],
            "transcript_text": """
            田中部長: 本日はお忙しい中お集まりいただきありがとうございます。
            佐藤主任: プロジェクトの進捗について報告いたします。
            鈴木さん: 開発は順調に進んでおり、予定通り完了予定です。
            """
        }
        
        minutes_response = client.post("/api/v1/minutes/generate", 
                                     json=meeting_data, headers=headers)
        assert minutes_response.status_code == 200
        
        # Step 6: 生成結果検証
        minutes_result = minutes_response.json()
        assert "meeting_title" in minutes_result
        assert "summary" in minutes_result
        assert "action_items" in minutes_result
        
        # Step 7: ヘルスチェック（認証不要）
        health_response = client.get("/health")
        assert health_response.status_code == 200
        assert health_response.json()["status"] == "healthy"
    
    def test_unauthorized_access_prevention(self):
        """未認証アクセス防止の包括テスト"""
        # 認証なしでの各種アクセス試行
        unauthorized_attempts = [
            ("GET", "/"),
            ("GET", "/docs"),
            ("GET", "/redoc"),
            ("POST", "/api/v1/minutes/generate", {
                "meeting_title": "Test",
                "transcript_text": "Test content"
            })
        ]
        
        for method, endpoint, *data in unauthorized_attempts:
            if method == "GET":
                response = client.get(endpoint)
            elif method == "POST":
                response = client.post(endpoint, json=data[0] if data else {})
            
            assert response.status_code == 401
            assert "Authorization header required" in response.json()["detail"]
```

## 6. セキュリティテスト仕様

### 6.1 認証セキュリティテスト

#### 6.1.1 トークンセキュリティテスト
```python
# tests/security/test_token_security.py
import pytest
import jwt
from datetime import datetime, timedelta
from fastapi.testclient import TestClient
from src.main import app
from src.config import settings

client = TestClient(app)

class TestTokenSecurity:
    def test_token_tampering_detection(self):
        """トークン改ざん検出テスト"""
        # 正常なトークン取得
        client.post("/api/v1/auth/register", json={
            "username": "tampertest",
            "email": "tamper@example.com",
            "password": "tamperpass123"
        })
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "tampertest",
            "password": "tamperpass123"
        })
        original_token = login_response.json()["access_token"]
        
        # トークンを改ざん
        tampered_token = original_token[:-10] + "tampered123"
        
        # 改ざんされたトークンでアクセス
        response = client.get("/", headers={
            "Authorization": f"Bearer {tampered_token}"
        })
        
        assert response.status_code == 401
        assert "Invalid or expired token" in response.json()["detail"]
    
    def test_expired_token_rejection(self):
        """期限切れトークン拒否テスト"""
        # 過去の時刻でトークン生成
        expired_payload = {
            "sub": "expireduser",
            "exp": datetime.utcnow() - timedelta(hours=1)
        }
        
        expired_token = jwt.encode(
            expired_payload,
            settings.jwt_secret_key,
            algorithm=settings.jwt_algorithm
        )
        
        response = client.get("/", headers={
            "Authorization": f"Bearer {expired_token}"
        })
        
        assert response.status_code == 401
        assert "Invalid or expired token" in response.json()["detail"]
    
    def test_malformed_token_handling(self):
        """不正形式トークン処理テスト"""
        malformed_tokens = [
            "not.a.jwt",
            "Bearer malformed",
            "completely_invalid",
            "",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9"  # 不完全なJWT
        ]
        
        for token in malformed_tokens:
            response = client.get("/", headers={
                "Authorization": f"Bearer {token}"
            })
            
            assert response.status_code == 401
            assert "Invalid" in response.json()["detail"]
    
    def test_token_reuse_security(self):
        """トークン再利用セキュリティテスト"""
        # 正常なトークン取得
        client.post("/api/v1/auth/register", json={
            "username": "reusetest",
            "email": "reuse@example.com",
            "password": "reusepass123"
        })
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "reusetest",
            "password": "reusepass123"
        })
        token = login_response.json()["access_token"]
        
        # 複数回の同一トークン使用
        for _ in range(5):
            response = client.get("/", headers={
                "Authorization": f"Bearer {token}"
            })
            assert response.status_code == 200
        
        # トークンは有効期限内であれば再利用可能（ステートレス）
```

### 6.2 認証バイパステスト

#### 6.2.1 認証回避試行テスト
```python
class TestAuthenticationBypass:
    def test_header_injection_attempts(self):
        """ヘッダーインジェクション試行テスト"""
        bypass_attempts = [
            {"X-User": "admin"},
            {"X-Forwarded-User": "admin"},
            {"X-Remote-User": "admin"},
            {"Authorization": "Basic YWRtaW46cGFzc3dvcmQ="},  # Basic認証
            {"Authorization": "Digest username=admin"},
            {"Authorization": "Bearer"},  # 空のBearer
            {"Authorization": "bearer valid_token"},  # 小文字scheme
        ]
        
        for headers in bypass_attempts:
            response = client.get("/", headers=headers)
            assert response.status_code == 401
    
    def test_path_traversal_attempts(self):
        """パストラバーサル試行テスト"""
        traversal_paths = [
            "/../api/v1/minutes/generate",
            "/./api/v1/minutes/generate",
            "//api/v1/minutes/generate",
            "/api/v1/auth/login/../../../",
            "/api/v1/auth/register/../../minutes/generate"
        ]
        
        for path in traversal_paths:
            response = client.get(path)
            # パストラバーサルが成功しても認証は必要
            if response.status_code != 404:  # 有効なパスの場合
                assert response.status_code == 401
    
    def test_method_override_attempts(self):
        """HTTPメソッドオーバーライド試行テスト"""
        override_headers = [
            {"X-HTTP-Method-Override": "GET"},
            {"X-Method-Override": "GET"},
            {"X-HTTP-Method": "GET"}
        ]
        
        for headers in override_headers:
            response = client.post("/api/v1/minutes/generate", 
                                 headers=headers,
                                 json={"test": "data"})
            assert response.status_code == 401
```

## 7. パフォーマンステスト仕様

### 7.1 認証処理性能テスト

#### 7.1.1 ミドルウェア性能テスト
```python
# tests/performance/test_auth_performance.py
import pytest
import time
from concurrent.futures import ThreadPoolExecutor
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestAuthenticationPerformance:
    def setup_method(self):
        """テスト用ユーザーとトークン準備"""
        client.post("/api/v1/auth/register", json={
            "username": "perftest",
            "email": "perf@example.com",
            "password": "perfpass123"
        })
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "perftest",
            "password": "perfpass123"
        })
        self.token = login_response.json()["access_token"]
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    def test_single_request_latency(self):
        """単一リクエストレイテンシテスト"""
        start_time = time.time()
        response = client.get("/", headers=self.headers)
        end_time = time.time()
        
        assert response.status_code == 200
        latency = end_time - start_time
        assert latency < 0.1  # 100ms以下
    
    def test_concurrent_authentication(self):
        """並行認証処理テスト"""
        def make_request():
            return client.get("/", headers=self.headers)
        
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(make_request) for _ in range(50)]
            results = [future.result() for future in futures]
        
        end_time = time.time()
        
        # 全リクエストが成功
        for result in results:
            assert result.status_code == 200
        
        # 平均レスポンス時間
        avg_time = (end_time - start_time) / 50
        assert avg_time < 0.05  # 50ms以下
    
    def test_authentication_failure_performance(self):
        """認証失敗時の性能テスト"""
        invalid_headers = {"Authorization": "Bearer invalid_token"}
        
        start_time = time.time()
        for _ in range(100):
            response = client.get("/", headers=invalid_headers)
            assert response.status_code == 401
        end_time = time.time()
        
        avg_time = (end_time - start_time) / 100
        assert avg_time < 0.01  # 10ms以下（失敗は高速であるべき）
    
    def test_memory_usage_stability(self):
        """メモリ使用量安定性テスト"""
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss
        
        # 大量のリクエスト実行
        for _ in range(1000):
            client.get("/", headers=self.headers)
        
        final_memory = process.memory_info().rss
        memory_increase = final_memory - initial_memory
        
        # メモリ増加が10MB以下
        assert memory_increase < 10 * 1024 * 1024
```

## 8. テスト実行戦略

### 8.1 テスト実行順序
```bash
# 1. ユニットテスト実行
pytest tests/unit/ -v

# 2. 統合テスト実行
pytest tests/integration/ -v

# 3. エンドツーエンドテスト実行
pytest tests/e2e/ -v

# 4. セキュリティテスト実行
pytest tests/security/ -v

# 5. パフォーマンステスト実行
pytest tests/performance/ -v

# 6. 全テスト実行
pytest tests/ -v --cov=src --cov-report=html
```

### 8.2 継続的インテグレーション設定
```yaml
# .github/workflows/test.yml
name: Authentication System Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.12
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio pytest-cov
    
    - name: Run unit tests
      run: pytest tests/unit/ -v
    
    - name: Run integration tests
      run: pytest tests/integration/ -v
    
    - name: Run security tests
      run: pytest tests/security/ -v
    
    - name: Generate coverage report
      run: pytest tests/ --cov=src --cov-report=xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
```

### 8.3 テストデータ管理
```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.modules.user_store import user_store

@pytest.fixture
def client():
    """テストクライアント"""
    return TestClient(app)

@pytest.fixture(autouse=True)
def clean_user_store():
    """各テスト後にユーザーストアをクリア"""
    yield
    user_store._users.clear()

@pytest.fixture
def test_user():
    """テスト用ユーザー"""
    return {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpass123"
    }

@pytest.fixture
def authenticated_headers(client, test_user):
    """認証済みヘッダー"""
    # ユーザー登録
    client.post("/api/v1/auth/register", json=test_user)
    
    # ログイン
    login_response = client.post("/api/v1/auth/login", data={
        "username": test_user["username"],
        "password": test_user["password"]
    })
    
    token = login_response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}
```

## 9. テスト品質保証

### 9.1 カバレッジ要件
- **ユニットテスト**: 90%以上のコードカバレッジ
- **統合テスト**: 主要フローの100%カバレッジ
- **ミドルウェアテスト**: 全パス・全エラーケースのカバレッジ
- **セキュリティテスト**: 脆弱性シナリオの網羅的テスト

### 9.2 テスト品質チェックリスト
- [ ] 全ユニットテストが独立して実行可能
- [ ] テストデータの適切なクリーンアップ
- [ ] 非同期処理の適切なテスト
- [ ] エラーケースの網羅的テスト
- [ ] パフォーマンス要件の検証
- [ ] セキュリティ脆弱性の検証
- [ ] ドキュメントとテストの整合性

### 9.3 テスト保守戦略
- **定期的なテスト見直し**: 月次でテストケースの有効性確認
- **新機能追加時**: 対応するテストケースの追加
- **バグ修正時**: 回帰テストケースの追加
- **パフォーマンス監視**: 継続的なパフォーマンステスト実行

## 10. まとめ

このテスト仕様書_ログイン_01では、実装計画_ログイン_03で設計されたアプリケーション全体保護認証システムの包括的なテスト戦略を定義しています。

### テスト対象の主要機能：
- **ミドルウェアベース認証**: アプリケーション全体の保護
- **JWT認証システム**: トークンベースの認証
- **メモリ内ユーザー管理**: 軽量なユーザーデータ管理
- **除外パス機能**: 認証エンドポイントの除外

### テストレベル：
- **ユニットテスト**: 個別モジュールの機能検証
- **統合テスト**: モジュール間連携の検証
- **E2Eテスト**: 完全なユーザージャーニーの検証
- **セキュリティテスト**: 認証・認可の脆弱性検証
- **パフォーマンステスト**: 認証処理の性能検証

### 品質保証：
- **高いカバレッジ**: 90%以上のコードカバレッジ目標
- **継続的テスト**: CI/CDパイプラインでの自動テスト
- **セキュリティ重視**: 認証バイパス試行の網羅的テスト
- **パフォーマンス監視**: レスポンス時間とメモリ使用量の監視

この仕様に基づいてテストを実装することで、アプリケーション全体保護認証システムの信頼性とセキュリティを確保できます。
