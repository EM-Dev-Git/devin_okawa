# テスト仕様書_ログイン_01 (アプリケーション全体保護版)

## 1. テスト概要

### 1.1 目的
実装計画_ログイン_03で設計されたFastAPIアプリケーション全体保護認証システムの品質保証を行う。
ミドルウェアベースの認証機能、セッション認証、メモリ内ユーザー管理の動作を包括的に検証する。

### 1.2 テスト対象システム
- **システム名**: FastAPI Azure OpenAI議事録生成システム
- **認証方式**: セッションベース + ミドルウェア
- **保護範囲**: アプリケーション全体（`http://localhost:8000/*`）
- **ユーザー管理**: メモリ内Python辞書
- **除外パス**: `/api/v1/auth/login`, `/api/v1/auth/register`, `/api/v1/auth/logout`, `/login`, `/health`

### 1.3 テスト範囲
- **ユニットテスト**: 個別モジュールの機能検証
- **統合テスト**: モジュール間連携の検証
- **ミドルウェアテスト**: 認証ミドルウェアの動作検証
- **エンドツーエンドテスト**: 全体フローの検証
- **セキュリティテスト**: 認証・認可の脆弱性検証
- **パフォーマンステスト**: 認証処理の性能検証

## 2. テスト環境

### 2.1 テスト環境構成
```
テスト環境:
├── Python 3.12+
├── FastAPI
├── pytest
├── pytest-asyncio
├── httpx (TestClient)
├── メモリ内データベース
└── モックAzure OpenAI API
```

### 2.2 テストデータ
```python
# テスト用ユーザーデータ
TEST_USERS = {
    "valid_user": {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123"
    },
    "admin_user": {
        "username": "admin",
        "email": "admin@example.com", 
        "password": "adminpassword123"
    },
    "invalid_user": {
        "username": "invalid",
        "email": "invalid@example.com",
        "password": "wrongpassword"
    }
}

# テスト用セッションデータ
TEST_SESSIONS = {
    "valid_session": {
        "user_id": "testuser",
        "created_at": "2025-07-15T10:00:00",
        "expires_at": "2025-07-16T10:00:00"
    },
    "expired_session": {
        "user_id": "testuser",
        "created_at": "2025-07-14T10:00:00",
        "expires_at": "2025-07-14T10:00:00"
    },
    "invalid_session": {
        "user_id": "nonexistent",
        "created_at": "2025-07-15T10:00:00"
    }
}
```

## 3. ユニットテスト仕様

### 3.1 認証ユーティリティテスト (src/modules/auth.py)

#### 3.1.1 パスワードハッシュ化テスト
```python
# tests/unit/test_auth_utils.py
import pytest
from src.modules.auth import get_password_hash, verify_password

class TestPasswordHashing:
    def test_password_hash_generation(self):
        """パスワードハッシュ化の正常動作テスト"""
        password = "testpassword123"
        hashed = get_password_hash(password)
        
        assert hashed is not None
        assert hashed != password
        assert len(hashed) > 0
        assert isinstance(hashed, str)
    
    def test_password_verification_success(self):
        """パスワード検証成功テスト"""
        password = "testpassword123"
        hashed = get_password_hash(password)
        
        assert verify_password(password, hashed) is True
    
    def test_password_verification_failure(self):
        """パスワード検証失敗テスト"""
        password = "testpassword123"
        wrong_password = "wrongpassword"
        hashed = get_password_hash(password)
        
        assert verify_password(wrong_password, hashed) is False
    
    def test_empty_password_handling(self):
        """空パスワードの処理テスト"""
        with pytest.raises(ValueError):
            get_password_hash("")
    
    def test_unicode_password_support(self):
        """Unicode文字を含むパスワードのテスト"""
        password = "パスワード123"
        hashed = get_password_hash(password)
        
        assert verify_password(password, hashed) is True
```

#### 3.1.2 セッション管理テスト
```python
class TestSessionOperations:
    def test_session_creation(self):
        """セッション作成テスト"""
        from starlette.requests import Request
        from starlette.middleware.sessions import SessionMiddleware
        
        # モックリクエストでセッション作成
        request = Mock(spec=Request)
        request.session = {}
        
        create_user_session(request, "testuser")
        
        assert request.session.get("user_id") == "testuser"
        assert "created_at" in request.session
        assert isinstance(request.session["created_at"], str)
    
    def test_session_validation_success(self):
        """セッション検証成功テスト"""
        request = Mock(spec=Request)
        request.session = {
            "user_id": "testuser",
            "created_at": datetime.utcnow().isoformat()
        }
        
        user_id = validate_user_session(request)
        assert user_id == "testuser"
    
    def test_session_validation_failure(self):
        """セッション検証失敗テスト"""
        request = Mock(spec=Request)
        request.session = {}  # 空のセッション
        
        user_id = validate_user_session(request)
        assert user_id is None
    
    def test_session_expiration_handling(self):
        """セッション期限切れ処理テスト"""
        request = Mock(spec=Request)
        # 過去の時刻でセッション作成
        expired_time = datetime.utcnow() - timedelta(hours=25)
        request.session = {
            "user_id": "testuser",
            "created_at": expired_time.isoformat()
        }
        
        user_id = validate_user_session(request)
        assert user_id is None  # 期限切れで無効
    
    def test_session_cleanup(self):
        """セッションクリーンアップテスト"""
        request = Mock(spec=Request)
        request.session = {
            "user_id": "testuser",
            "created_at": datetime.utcnow().isoformat()
        }
        
        clear_user_session(request)
        assert "user_id" not in request.session
        assert "created_at" not in request.session
```

### 3.2 ユーザーストアテスト (src/modules/user_store.py)

#### 3.2.1 ユーザー管理テスト
```python
# tests/unit/test_user_store.py
import pytest
from src.modules.user_store import UserStore

class TestUserStore:
    def setup_method(self):
        """各テスト前の初期化"""
        self.user_store = UserStore()
    
    def test_user_creation(self):
        """ユーザー作成テスト"""
        user = self.user_store.create_user(
            "testuser", 
            "test@example.com", 
            "hashedpassword"
        )
        
        assert user["username"] == "testuser"
        assert user["email"] == "test@example.com"
        assert user["is_active"] is True
        assert "created_at" in user
        assert "hashed_password" not in user  # レスポンスに含まれない
    
    def test_duplicate_user_creation(self):
        """重複ユーザー作成テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        with pytest.raises(ValueError, match="Username already exists"):
            self.user_store.create_user("testuser", "other@example.com", "hash")
    
    def test_user_retrieval_by_username(self):
        """ユーザー名による取得テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        user = self.user_store.get_user_by_username("testuser")
        assert user is not None
        assert user["username"] == "testuser"
        
        non_user = self.user_store.get_user_by_username("nonexistent")
        assert non_user is None
    
    def test_user_retrieval_by_email(self):
        """メールアドレスによる取得テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        user = self.user_store.get_user_by_email("test@example.com")
        assert user is not None
        assert user["email"] == "test@example.com"
    
    def test_user_deletion(self):
        """ユーザー削除テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        result = self.user_store.delete_user("testuser")
        assert result is True
        
        user = self.user_store.get_user_by_username("testuser")
        assert user is None
    
    def test_user_update(self):
        """ユーザー更新テスト"""
        self.user_store.create_user("testuser", "test@example.com", "hash")
        
        updated_user = self.user_store.update_user(
            "testuser", 
            email="newemail@example.com",
            is_active=False
        )
        
        assert updated_user["email"] == "newemail@example.com"
        assert updated_user["is_active"] is False
```

### 3.3 認証ミドルウェアテスト (src/middleware/auth.py)

#### 3.3.1 ミドルウェア動作テスト
```python
# tests/unit/test_auth_middleware.py
import pytest
from unittest.mock import Mock, AsyncMock
from fastapi import Request
from src.middleware.auth import SessionAuthenticationMiddleware

class TestSessionAuthenticationMiddleware:
    def setup_method(self):
        """各テスト前の初期化"""
        self.app = Mock()
        self.middleware = SessionAuthenticationMiddleware(self.app)
    
    @pytest.mark.asyncio
    async def test_excluded_path_bypass(self):
        """除外パスのバイパステスト"""
        request = Mock(spec=Request)
        request.url.path = "/api/v1/auth/login"
        call_next = AsyncMock(return_value="response")
        
        result = await self.middleware.dispatch(request, call_next)
        
        call_next.assert_called_once_with(request)
        assert result == "response"
    
    @pytest.mark.asyncio
    async def test_missing_session(self):
        """セッション不足テスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.session = {}  # 空のセッション
        call_next = AsyncMock()
        
        result = await self.middleware.dispatch(request, call_next)
        
        call_next.assert_not_called()
        assert result.status_code == 302  # リダイレクト
        assert "login" in result.headers.get("location", "").lower()
    
    @pytest.mark.asyncio
    async def test_invalid_session_user(self):
        """無効なセッションユーザーテスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.session = {"user_id": "nonexistent_user"}
        call_next = AsyncMock()
        
        with patch('src.middleware.auth.user_store.get_user_by_username') as mock_get_user:
            mock_get_user.return_value = None
            
            result = await self.middleware.dispatch(request, call_next)
            
            call_next.assert_not_called()
            assert result.status_code == 302  # リダイレクト
    
    @pytest.mark.asyncio
    async def test_valid_session_processing(self):
        """有効セッションの処理テスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.session = {"user_id": "testuser"}
        request.state = Mock()
        call_next = AsyncMock(return_value="success_response")
        
        with patch('src.middleware.auth.user_store.get_user_by_username') as mock_get_user:
            mock_get_user.return_value = {"username": "testuser", "is_active": True}
            
            result = await self.middleware.dispatch(request, call_next)
            
            mock_get_user.assert_called_once_with("testuser")
            call_next.assert_called_once_with(request)
            assert request.state.current_user == "testuser"
            assert result == "success_response"
    
    @pytest.mark.asyncio
    async def test_expired_session_handling(self):
        """期限切れセッションの処理テスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        expired_time = datetime.utcnow() - timedelta(hours=25)
        request.session = {
            "user_id": "testuser",
            "created_at": expired_time.isoformat()
        }
        call_next = AsyncMock()
        
        result = await self.middleware.dispatch(request, call_next)
        
        call_next.assert_not_called()
        assert result.status_code == 302  # リダイレクト
        assert "user_id" not in request.session  # セッションクリア
    
    @pytest.mark.asyncio
    async def test_inactive_user_handling(self):
        """非アクティブユーザーの処理テスト"""
        request = Mock(spec=Request)
        request.url.path = "/protected"
        request.session = {"user_id": "inactive_user"}
        call_next = AsyncMock()
        
        with patch('src.middleware.auth.user_store.get_user_by_username') as mock_get_user:
            mock_get_user.return_value = {"username": "inactive_user", "is_active": False}
            
            result = await self.middleware.dispatch(request, call_next)
            
            call_next.assert_not_called()
            assert result.status_code == 302  # リダイレクト
```

## 4. 統合テスト仕様

### 4.1 認証フローテスト

#### 4.1.1 ユーザー登録・ログインフロー
```python
# tests/integration/test_auth_flow.py
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestAuthenticationFlow:
    def test_user_registration_and_login(self):
        """ユーザー登録からログインまでのフローテスト"""
        # ユーザー登録
        register_data = {
            "username": "flowtest",
            "email": "flowtest@example.com",
            "password": "flowtestpass123"
        }
        
        register_response = client.post("/api/v1/auth/register", json=register_data)
        assert register_response.status_code == 200
        
        user_data = register_response.json()
        assert user_data["username"] == "flowtest"
        assert user_data["email"] == "flowtest@example.com"
        assert user_data["is_active"] is True
        
        # ログイン（セッション作成）
        login_data = {
            "username": "flowtest",
            "password": "flowtestpass123"
        }
        
        login_response = client.post("/api/v1/auth/login", data=login_data)
        assert login_response.status_code == 200
        
        response_data = login_response.json()
        assert "message" in response_data
        assert "Login successful" in response_data["message"]
        
        # セッションCookieが設定されているかチェック
        assert "session" in login_response.cookies
        
        return login_response.cookies
    
    def test_protected_endpoint_access_with_session(self):
        """セッション認証を使用した保護エンドポイントアクセステスト"""
        session_cookies = self.test_user_registration_and_login()
        
        # セッションCookieを使用してクライアント設定
        client.cookies = session_cookies
        
        # ルートエンドポイント（セッション認証）
        root_response = client.get("/")
        assert root_response.status_code == 200
        
        # 議事録生成エンドポイント（セッション認証）
        minutes_data = {
            "meeting_title": "テスト会議",
            "meeting_date": "2025-07-15T10:00:00",
            "participants": ["テスト太郎", "テスト花子"],
            "transcript_text": "テスト会議の内容です。"
        }
        
        minutes_response = client.post("/api/v1/minutes/generate", json=minutes_data)
        assert minutes_response.status_code == 200
    
    def test_duplicate_registration_prevention(self):
        """重複登録防止テスト"""
        user_data = {
            "username": "duplicate",
            "email": "duplicate@example.com",
            "password": "password123"
        }
        
        # 初回登録
        first_response = client.post("/api/v1/auth/register", json=user_data)
        assert first_response.status_code == 200
        
        # 重複登録試行
        second_response = client.post("/api/v1/auth/register", json=user_data)
        assert second_response.status_code == 400
        assert "already registered" in second_response.json()["detail"]
```

#### 4.1.2 認証失敗フロー
```python
class TestAuthenticationFailures:
    def test_invalid_login_credentials(self):
        """無効な認証情報でのログインテスト"""
        # 存在しないユーザー
        invalid_data = {
            "username": "nonexistent",
            "password": "anypassword"
        }
        
        response = client.post("/api/v1/auth/login", data=invalid_data)
        assert response.status_code == 401
        assert "Incorrect username or password" in response.json()["detail"]
    
    def test_wrong_password_login(self):
        """間違ったパスワードでのログインテスト"""
        # ユーザー登録
        register_data = {
            "username": "wrongpass",
            "email": "wrongpass@example.com",
            "password": "correctpass123"
        }
        client.post("/api/v1/auth/register", json=register_data)
        
        # 間違ったパスワードでログイン
        login_data = {
            "username": "wrongpass",
            "password": "wrongpassword"
        }
        
        response = client.post("/api/v1/auth/login", data=login_data)
        assert response.status_code == 401
        assert "Incorrect username or password" in response.json()["detail"]
```

### 4.2 ミドルウェア統合テスト

#### 4.2.1 アプリケーション全体保護テスト
```python
# tests/integration/test_middleware_integration.py
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestMiddlewareIntegration:
    def test_all_endpoints_require_authentication(self):
        """全エンドポイントの認証必須テスト"""
        protected_endpoints = [
            "/",
            "/api/v1/minutes/generate",
            "/docs",
            "/redoc"
        ]
        
        for endpoint in protected_endpoints:
            response = client.get(endpoint, allow_redirects=False)
            assert response.status_code == 302, f"Endpoint {endpoint} should require authentication"
            assert "login" in response.headers.get("location", "").lower()
    
    def test_excluded_paths_accessibility(self):
        """除外パスのアクセス可能性テスト"""
        excluded_endpoints = [
            "/api/v1/auth/login",
            "/api/v1/auth/register",
            "/api/v1/auth/logout",
            "/login",
            "/health"
        ]
        
        for endpoint in excluded_endpoints:
            if endpoint == "/health":
                response = client.get(endpoint)
                assert response.status_code == 200, f"Endpoint {endpoint} should be accessible without auth"
            else:
                # 認証エンドポイントは適切なデータが必要だが、セッション認証は不要
                response = client.get(endpoint, allow_redirects=False)
                assert response.status_code != 302, f"Endpoint {endpoint} should not require session auth"
    
    def test_middleware_order_with_cors(self):
        """CORSミドルウェアとの順序テスト"""
        # OPTIONSリクエスト（CORS preflight）
        response = client.options("/", headers={
            "Origin": "http://localhost:3000",
            "Access-Control-Request-Method": "GET"
        })
        
        # CORSが先に処理されるため、認証エラーではなくCORS応答
        assert "access-control-allow-origin" in response.headers
    
    def test_request_state_user_injection(self):
        """リクエスト状態へのユーザー情報注入テスト"""
        # ユーザー登録とログイン
        register_data = {
            "username": "statetest",
            "email": "statetest@example.com",
            "password": "statetest123"
        }
        client.post("/api/v1/auth/register", json=register_data)
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "statetest",
            "password": "statetest123"
        })
        assert login_response.status_code == 200
        
        # セッションCookieを設定
        client.cookies = login_response.cookies
        
        # 保護されたエンドポイントでユーザー情報確認
        response = client.get("/")
        
        assert response.status_code == 200
        # レスポンスでユーザー情報が利用可能であることを確認
        # (実際の実装では、エンドポイントでrequest.state.current_userを使用)
```

## 5. エンドツーエンドテスト仕様

### 5.1 完全なユーザージャーニーテスト

#### 5.1.1 議事録生成フローテスト
```python
# tests/e2e/test_complete_flow.py
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestCompleteUserJourney:
    def test_complete_meeting_minutes_flow(self):
        """完全な議事録生成フローテスト"""
        # Step 1: ユーザー登録
        register_data = {
            "username": "meetinguser",
            "email": "meeting@example.com",
            "password": "meetingpass123"
        }
        
        register_response = client.post("/api/v1/auth/register", json=register_data)
        assert register_response.status_code == 200
        
        # Step 2: ログイン（セッション作成）
        login_response = client.post("/api/v1/auth/login", data={
            "username": "meetinguser",
            "password": "meetingpass123"
        })
        assert login_response.status_code == 200
        assert "Login successful" in login_response.json()["message"]
        
        # Step 3: セッションCookie設定
        client.cookies = login_response.cookies
        
        # Step 4: アプリケーション状態確認
        root_response = client.get("/")
        assert root_response.status_code == 200
        
        # Step 5: 議事録生成実行
        meeting_data = {
            "meeting_title": "プロジェクト進捗会議",
            "meeting_date": "2025-07-15T14:00:00",
            "participants": ["田中部長", "佐藤主任", "鈴木さん"],
            "transcript_text": """
            田中部長: 本日はお忙しい中お集まりいただきありがとうございます。
            佐藤主任: プロジェクトの進捗について報告いたします。
            鈴木さん: 開発は順調に進んでおり、予定通り完了予定です。
            """
        }
        
        minutes_response = client.post("/api/v1/minutes/generate", json=meeting_data)
        assert minutes_response.status_code == 200
        
        # Step 6: 生成結果検証
        minutes_result = minutes_response.json()
        assert "meeting_title" in minutes_result
        assert "summary" in minutes_result
        assert "action_items" in minutes_result
        
        # Step 7: ヘルスチェック（認証不要）
        health_response = client.get("/health")
        assert health_response.status_code == 200
        assert health_response.json()["status"] == "healthy"
    
    def test_unauthorized_access_prevention(self):
        """未認証アクセス防止の包括テスト"""
        # セッション認証なしでの各種アクセス試行
        unauthorized_attempts = [
            ("GET", "/"),
            ("GET", "/docs"),
            ("GET", "/redoc"),
            ("POST", "/api/v1/minutes/generate", {
                "meeting_title": "Test",
                "transcript_text": "Test content"
            })
        ]
        
        for method, endpoint, *data in unauthorized_attempts:
            if method == "GET":
                response = client.get(endpoint, allow_redirects=False)
            elif method == "POST":
                response = client.post(endpoint, json=data[0] if data else {}, allow_redirects=False)
            
            assert response.status_code == 302  # リダイレクト
            assert "login" in response.headers.get("location", "").lower()
```

## 6. セキュリティテスト仕様

### 6.1 認証セキュリティテスト

#### 6.1.1 セッションセキュリティテスト
```python
# tests/security/test_session_security.py
import pytest
from datetime import datetime, timedelta
from fastapi.testclient import TestClient
from src.main import app
from src.config import settings

client = TestClient(app)

class TestSessionSecurity:
    def test_session_tampering_detection(self):
        """セッション改ざん検出テスト"""
        # 正常なセッション作成
        client.post("/api/v1/auth/register", json={
            "username": "tampertest",
            "email": "tamper@example.com",
            "password": "tamperpass123"
        })
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "tampertest",
            "password": "tamperpass123"
        })
        
        # セッションCookieを改ざん
        original_cookies = login_response.cookies
        tampered_cookies = original_cookies.copy()
        if "session" in tampered_cookies:
            tampered_cookies["session"] = tampered_cookies["session"][:-10] + "tampered123"
        
        # 改ざんされたセッションでアクセス
        client.cookies = tampered_cookies
        response = client.get("/", allow_redirects=False)
        
        assert response.status_code == 302  # リダイレクト
        assert "login" in response.headers.get("location", "").lower()
    
    def test_expired_session_rejection(self):
        """期限切れセッション拒否テスト"""
        # ユーザー登録
        client.post("/api/v1/auth/register", json={
            "username": "expiredtest",
            "email": "expired@example.com",
            "password": "expiredpass123"
        })
        
        # ログイン
        login_response = client.post("/api/v1/auth/login", data={
            "username": "expiredtest",
            "password": "expiredpass123"
        })
        client.cookies = login_response.cookies
        
        # セッション期限を過去に設定（モック使用）
        with patch('src.middleware.auth.datetime') as mock_datetime:
            mock_datetime.utcnow.return_value = datetime.utcnow() + timedelta(hours=25)
            
            response = client.get("/", allow_redirects=False)
            
            assert response.status_code == 302  # リダイレクト
            assert "login" in response.headers.get("location", "").lower()
    
    def test_session_fixation_prevention(self):
        """セッション固定攻撃防止テスト"""
        # 攻撃者が事前にセッションを作成
        attacker_response = client.get("/api/v1/auth/login")
        attacker_cookies = attacker_response.cookies
        
        # 被害者がそのセッションでログイン試行
        client.cookies = attacker_cookies
        login_response = client.post("/api/v1/auth/login", data={
            "username": "victim",
            "password": "victimpass123"
        })
        
        # ログイン後、新しいセッションIDが生成されるべき
        new_cookies = login_response.cookies
        if "session" in attacker_cookies and "session" in new_cookies:
            assert attacker_cookies["session"] != new_cookies["session"]
    
    def test_concurrent_session_handling(self):
        """並行セッション処理テスト"""
        # ユーザー登録
        client.post("/api/v1/auth/register", json={
            "username": "concurrenttest",
            "email": "concurrent@example.com",
            "password": "concurrentpass123"
        })
        
        # 複数のクライアントで同時ログイン
        clients = [TestClient(app) for _ in range(3)]
        
        for test_client in clients:
            login_response = test_client.post("/api/v1/auth/login", data={
                "username": "concurrenttest",
                "password": "concurrentpass123"
            })
            assert login_response.status_code == 200
            
            test_client.cookies = login_response.cookies
            response = test_client.get("/")
            assert response.status_code == 200
    
    def test_session_logout_cleanup(self):
        """ログアウト時のセッションクリーンアップテスト"""
        # ログイン
        client.post("/api/v1/auth/register", json={
            "username": "logouttest",
            "email": "logout@example.com",
            "password": "logoutpass123"
        })
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "logouttest",
            "password": "logoutpass123"
        })
        client.cookies = login_response.cookies
        
        # ログイン状態確認
        response = client.get("/")
        assert response.status_code == 200
        
        # ログアウト
        logout_response = client.post("/api/v1/auth/logout")
        assert logout_response.status_code == 200
        
        # ログアウト後のアクセス試行
        response = client.get("/", allow_redirects=False)
        assert response.status_code == 302  # リダイレクト
```

### 6.2 認証バイパステスト

#### 6.2.1 認証回避試行テスト
```python
class TestAuthenticationBypass:
    def test_header_injection_attempts(self):
        """ヘッダーインジェクション試行テスト"""
        bypass_attempts = [
            {"X-User": "admin"},
            {"X-Forwarded-User": "admin"},
            {"X-Remote-User": "admin"},
            {"X-Session-User": "admin"},
            {"Authorization": "Basic YWRtaW46cGFzc3dvcmQ="},  # Basic認証
            {"Authorization": "Digest username=admin"},
            {"Authorization": "Bearer fake_token"},
            {"X-Authenticated": "true"},
        ]
        
        for headers in bypass_attempts:
            response = client.get("/", headers=headers, allow_redirects=False)
            assert response.status_code == 302  # リダイレクト
    
    def test_path_traversal_attempts(self):
        """パストラバーサル試行テスト"""
        traversal_paths = [
            "/../api/v1/minutes/generate",
            "/./api/v1/minutes/generate",
            "//api/v1/minutes/generate",
            "/api/v1/auth/login/../../../",
            "/api/v1/auth/register/../../minutes/generate"
        ]
        
        for path in traversal_paths:
            response = client.get(path, allow_redirects=False)
            # パストラバーサルが成功しても認証は必要
            if response.status_code != 404:  # 有効なパスの場合
                assert response.status_code == 302  # リダイレクト
    
    def test_method_override_attempts(self):
        """HTTPメソッドオーバーライド試行テスト"""
        override_headers = [
            {"X-HTTP-Method-Override": "GET"},
            {"X-Method-Override": "GET"},
            {"X-HTTP-Method": "GET"}
        ]
        
        for headers in override_headers:
            response = client.post("/api/v1/minutes/generate", 
                                 headers=headers,
                                 json={"test": "data"},
                                 allow_redirects=False)
            assert response.status_code == 302  # リダイレクト
```

## 7. パフォーマンステスト仕様

### 7.1 認証処理性能テスト

#### 7.1.1 ミドルウェア性能テスト
```python
# tests/performance/test_auth_performance.py
import pytest
import time
from concurrent.futures import ThreadPoolExecutor
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

class TestAuthenticationPerformance:
    def setup_method(self):
        """テスト用ユーザーとセッション準備"""
        client.post("/api/v1/auth/register", json={
            "username": "perftest",
            "email": "perf@example.com",
            "password": "perfpass123"
        })
        
        login_response = client.post("/api/v1/auth/login", data={
            "username": "perftest",
            "password": "perfpass123"
        })
        assert login_response.status_code == 200
        client.cookies = login_response.cookies
    
    def test_single_request_latency(self):
        """単一リクエストレイテンシテスト"""
        start_time = time.time()
        response = client.get("/")
        end_time = time.time()
        
        assert response.status_code == 200
        latency = end_time - start_time
        assert latency < 0.1  # 100ms以下
    
    def test_concurrent_session_authentication(self):
        """並行セッション認証処理テスト"""
        def make_request():
            return client.get("/")
        
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(make_request) for _ in range(50)]
            results = [future.result() for future in futures]
        
        end_time = time.time()
        
        # 全リクエストが成功
        for result in results:
            assert result.status_code == 200
        
        # 平均レスポンス時間
        avg_time = (end_time - start_time) / 50
        assert avg_time < 0.05  # 50ms以下
    
    def test_authentication_failure_performance(self):
        """認証失敗時の性能テスト"""
        # セッションなしのクライアント作成
        unauthenticated_client = TestClient(app)
        
        start_time = time.time()
        for _ in range(100):
            response = unauthenticated_client.get("/", allow_redirects=False)
            assert response.status_code == 302  # リダイレクト
        end_time = time.time()
        
        avg_time = (end_time - start_time) / 100
        assert avg_time < 0.01  # 10ms以下（失敗は高速であるべき）
    
    def test_memory_usage_stability(self):
        """メモリ使用量安定性テスト"""
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss
        
        # 大量のリクエスト実行
        for _ in range(1000):
            client.get("/")
        
        final_memory = process.memory_info().rss
        memory_increase = final_memory - initial_memory
        
        # メモリ増加が10MB以下
        assert memory_increase < 10 * 1024 * 1024
```

## 8. テスト実行戦略

### 8.1 テスト実行順序
```bash
# 1. ユニットテスト実行
pytest tests/unit/ -v

# 2. 統合テスト実行
pytest tests/integration/ -v

# 3. エンドツーエンドテスト実行
pytest tests/e2e/ -v

# 4. セキュリティテスト実行
pytest tests/security/ -v

# 5. パフォーマンステスト実行
pytest tests/performance/ -v

# 6. 全テスト実行
pytest tests/ -v --cov=src --cov-report=html
```

### 8.2 継続的インテグレーション設定
```yaml
# .github/workflows/test.yml
name: Authentication System Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.12
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio pytest-cov
    
    - name: Run unit tests
      run: pytest tests/unit/ -v
    
    - name: Run integration tests
      run: pytest tests/integration/ -v
    
    - name: Run security tests
      run: pytest tests/security/ -v
    
    - name: Generate coverage report
      run: pytest tests/ --cov=src --cov-report=xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
```

### 8.3 テストデータ管理
```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.modules.user_store import user_store

@pytest.fixture
def client():
    """テストクライアント"""
    return TestClient(app)

@pytest.fixture(autouse=True)
def clean_user_store():
    """各テスト後にユーザーストアをクリア"""
    yield
    user_store._users.clear()

@pytest.fixture
def test_user():
    """テスト用ユーザー"""
    return {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpass123"
    }

@pytest.fixture
def authenticated_client(client, test_user):
    """認証済みクライアント"""
    # ユーザー登録
    client.post("/api/v1/auth/register", json=test_user)
    
    # ログイン（セッション作成）
    login_response = client.post("/api/v1/auth/login", data={
        "username": test_user["username"],
        "password": test_user["password"]
    })
    
    assert login_response.status_code == 200
    client.cookies = login_response.cookies
    return client
```

## 9. テスト品質保証

### 9.1 カバレッジ要件
- **ユニットテスト**: 90%以上のコードカバレッジ
- **統合テスト**: 主要フローの100%カバレッジ
- **ミドルウェアテスト**: 全パス・全エラーケースのカバレッジ
- **セキュリティテスト**: 脆弱性シナリオの網羅的テスト

### 9.2 テスト品質チェックリスト
- [ ] 全ユニットテストが独立して実行可能
- [ ] テストデータの適切なクリーンアップ
- [ ] 非同期処理の適切なテスト
- [ ] エラーケースの網羅的テスト
- [ ] パフォーマンス要件の検証
- [ ] セキュリティ脆弱性の検証
- [ ] ドキュメントとテストの整合性

### 9.3 テスト保守戦略
- **定期的なテスト見直し**: 月次でテストケースの有効性確認
- **新機能追加時**: 対応するテストケースの追加
- **バグ修正時**: 回帰テストケースの追加
- **パフォーマンス監視**: 継続的なパフォーマンステスト実行

## 10. まとめ

このテスト仕様書_ログイン_01では、実装計画_ログイン_03で設計されたアプリケーション全体保護認証システムの包括的なテスト戦略を定義しています。

### テスト対象の主要機能：
- **ミドルウェアベース認証**: アプリケーション全体の保護
- **セッション認証システム**: セッションベースの認証
- **メモリ内ユーザー管理**: 軽量なユーザーデータ管理
- **除外パス機能**: 認証エンドポイントの除外

### テストレベル：
- **ユニットテスト**: 個別モジュールの機能検証
- **統合テスト**: モジュール間連携の検証
- **E2Eテスト**: 完全なユーザージャーニーの検証
- **セキュリティテスト**: 認証・認可の脆弱性検証
- **パフォーマンステスト**: 認証処理の性能検証

### 品質保証：
- **高いカバレッジ**: 90%以上のコードカバレッジ目標
- **継続的テスト**: CI/CDパイプラインでの自動テスト
- **セキュリティ重視**: セッション認証バイパス試行の網羅的テスト
- **パフォーマンス監視**: レスポンス時間とメモリ使用量の監視
- **セッション管理**: セッション作成、検証、クリーンアップの包括的テスト

この仕様に基づいてテストを実装することで、セッションベースのアプリケーション全体保護認証システムの信頼性とセキュリティを確保できます。
