# FastAPI 議事録生成アプリ 総合テスト仕様書

## 1. テスト概要

### 1.1 テスト目的
FastAPIを使用した議事録生成アプリケーションのシステム全体の品質保証を行う。
セキュリティ、パフォーマンス、エラーハンドリング、運用面での要件を満たすことを確認する。

### 1.2 テスト対象
- セキュリティ機能（認証、認可、入力値検証）
- パフォーマンス（負荷、レスポンス時間）
- エラーハンドリング（例外処理、ネットワークエラー）
- システム全体の統合動作
- 運用・保守性

### 1.3 テスト環境
- **テストフレームワーク**: pytest
- **HTTPクライアント**: FastAPI TestClient
- **負荷テスト**: concurrent.futures
- **セキュリティテスト**: 各種攻撃パターン
- **Python バージョン**: 3.8+

### 1.4 テスト戦略
- **セキュリティファースト**: 脆弱性の徹底的な検証
- **実運用想定**: 本番環境に近い条件でのテスト
- **境界値テスト**: システム限界での動作確認
- **障害シミュレーション**: 各種エラー条件での動作確認

## 2. セキュリティテスト仕様

### 2.1 認証セキュリティテスト (test_security.py)

#### 2.1.1 JWTトークンセキュリティテスト
```python
import jwt
from datetime import datetime, timedelta
from src.config import settings

def test_expired_token(client, test_user_data, clean_user_store):
    """期限切れトークンテスト"""
    # ユーザー登録
    client.post("/api/v1/auth/register", json=test_user_data)
    
    # 期限切れトークンを手動作成
    expired_payload = {
        "sub": test_user_data["username"],
        "exp": datetime.utcnow() - timedelta(minutes=1)  # 1分前に期限切れ
    }
    expired_token = jwt.encode(expired_payload, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)
    
    headers = {"Authorization": f"Bearer {expired_token}"}
    response = client.get("/api/v1/auth/me", headers=headers)
    
    assert response.status_code == 401

def test_malformed_token(client):
    """不正な形式のトークンテスト"""
    headers = {"Authorization": "Bearer malformed.token"}
    response = client.get("/api/v1/auth/me", headers=headers)
    
    assert response.status_code == 401

def test_missing_bearer_prefix(client, authenticated_headers):
    """Bearerプレフィックス欠如テスト"""
    token = authenticated_headers["Authorization"].replace("Bearer ", "")
    headers = {"Authorization": token}
    response = client.get("/api/v1/auth/me", headers=headers)
    
    assert response.status_code == 401

def test_token_with_wrong_secret(client, test_user_data, clean_user_store):
    """間違った秘密鍵で作成されたトークンテスト"""
    # ユーザー登録
    client.post("/api/v1/auth/register", json=test_user_data)
    
    # 間違った秘密鍵でトークン作成
    wrong_payload = {"sub": test_user_data["username"]}
    wrong_token = jwt.encode(wrong_payload, "wrong_secret_key", algorithm=settings.jwt_algorithm)
    
    headers = {"Authorization": f"Bearer {wrong_token}"}
    response = client.get("/api/v1/auth/me", headers=headers)
    
    assert response.status_code == 401

def test_token_algorithm_confusion(client, test_user_data, clean_user_store):
    """アルゴリズム混同攻撃テスト"""
    # ユーザー登録
    client.post("/api/v1/auth/register", json=test_user_data)
    
    # 異なるアルゴリズムでトークン作成
    payload = {"sub": test_user_data["username"]}
    wrong_algorithm_token = jwt.encode(payload, settings.jwt_secret_key, algorithm="HS512")
    
    headers = {"Authorization": f"Bearer {wrong_algorithm_token}"}
    response = client.get("/api/v1/auth/me", headers=headers)
    
    assert response.status_code == 401
```

#### 2.1.2 パスワードセキュリティテスト
```python
def test_password_strength_validation(client, clean_user_store):
    """パスワード強度検証テスト"""
    weak_passwords = [
        "123",
        "password",
        "abc",
        ""
    ]
    
    for weak_password in weak_passwords:
        user_data = {
            "username": f"user_{weak_password}",
            "email": f"user_{weak_password}@example.com",
            "password": weak_password
        }
        
        response = client.post("/api/v1/auth/register", json=user_data)
        # パスワード強度チェックが実装されている場合は400、そうでなければ200
        assert response.status_code in [200, 400, 422]

def test_password_hashing_uniqueness():
    """パスワードハッシュの一意性テスト"""
    from src.modules.auth import get_password_hash
    
    password = "testpassword123"
    hash1 = get_password_hash(password)
    hash2 = get_password_hash(password)
    
    # bcryptは同じパスワードでも異なるハッシュを生成する
    assert hash1 != hash2
    
    # しかし両方とも元のパスワードで検証できる
    from src.modules.auth import verify_password
    assert verify_password(password, hash1) is True
    assert verify_password(password, hash2) is True

def test_brute_force_protection(client, clean_user_store):
    """ブルートフォース攻撃保護テスト"""
    # テストユーザー作成
    user_data = {
        "username": "brutetest",
        "email": "brutetest@example.com",
        "password": "correctpassword123"
    }
    client.post("/api/v1/auth/register", json=user_data)
    
    # 複数回の失敗ログイン試行
    for i in range(10):
        login_data = {
            "username": "brutetest",
            "password": f"wrongpassword{i}"
        }
        response = client.post("/api/v1/auth/login", data=login_data)
        assert response.status_code == 401
    
    # 正しいパスワードでもログインできることを確認（レート制限がない場合）
    correct_login_data = {
        "username": "brutetest",
        "password": "correctpassword123"
    }
    response = client.post("/api/v1/auth/login", data=correct_login_data)
    # レート制限が実装されている場合は429、そうでなければ200
    assert response.status_code in [200, 429]
```

### 2.2 入力値検証テスト (test_input_validation.py)

#### 2.2.1 SQLインジェクション対策テスト
```python
def test_sql_injection_attempts(client, clean_user_store):
    """SQLインジェクション攻撃テスト"""
    malicious_inputs = [
        "'; DROP TABLE users; --",
        "admin'--",
        "' OR '1'='1",
        "1' UNION SELECT * FROM users--"
    ]
    
    for malicious_input in malicious_inputs:
        user_data = {
            "username": malicious_input,
            "email": "test@example.com",
            "password": "password123"
        }
        
        response = client.post("/api/v1/auth/register", json=user_data)
        # 適切に処理されることを確認（エラーまたは正常処理）
        assert response.status_code in [200, 400, 422]

def test_xss_prevention(client, authenticated_headers):
    """XSS攻撃防止テスト"""
    malicious_script = "<script>alert('XSS')</script>"
    
    transcript_data = {
        "meeting_title": malicious_script,
        "meeting_date": "2024-01-15T10:00:00",
        "participants": [malicious_script],
        "transcript_text": f"Meeting content with {malicious_script}",
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=transcript_data,
        headers=authenticated_headers
    )
    
    # レスポンスにスクリプトタグが含まれていないことを確認
    if response.status_code == 200:
        response_text = response.text
        assert "<script>" not in response_text
        assert "alert(" not in response_text

def test_command_injection_prevention(client, authenticated_headers):
    """コマンドインジェクション防止テスト"""
    malicious_commands = [
        "; rm -rf /",
        "| cat /etc/passwd",
        "&& curl malicious-site.com",
        "`whoami`"
    ]
    
    for malicious_command in malicious_commands:
        transcript_data = {
            "meeting_title": f"Meeting {malicious_command}",
            "meeting_date": "2024-01-15T10:00:00",
            "participants": ["Alice"],
            "transcript_text": f"Content {malicious_command}",
        }
        
        response = client.post(
            "/api/v1/minutes/generate",
            json=transcript_data,
            headers=authenticated_headers
        )
        
        # 適切に処理されることを確認
        assert response.status_code in [200, 400, 422, 500]

def test_path_traversal_prevention(client):
    """パストラバーサル攻撃防止テスト"""
    malicious_paths = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
    ]
    
    for malicious_path in malicious_paths:
        response = client.get(f"/{malicious_path}")
        # 404または適切なエラーレスポンスを確認
        assert response.status_code in [404, 400, 403]
```

#### 2.2.2 大容量データ処理テスト
```python
def test_large_transcript_handling(client, authenticated_headers):
    """大容量トランスクリプト処理テスト"""
    # 大容量のトランスクリプトデータ（1MB程度）
    large_transcript = "A" * (1024 * 1024)
    
    transcript_data = {
        "meeting_title": "Large Data Test",
        "meeting_date": "2024-01-15T10:00:00",
        "participants": ["Alice"],
        "transcript_text": large_transcript,
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=transcript_data,
        headers=authenticated_headers
    )
    
    # 適切に処理されることを確認（成功またはサイズ制限エラー）
    assert response.status_code in [200, 413, 422]

def test_unicode_handling(client, authenticated_headers):
    """Unicode文字処理テスト"""
    unicode_data = {
        "meeting_title": "会議タイトル 🚀 émojis ñ 中文",
        "meeting_date": "2024-01-15T10:00:00",
        "participants": ["アリス", "ボブ", "José"],
        "transcript_text": "会議内容です。絵文字 🎉 も含まれています。",
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=unicode_data,
        headers=authenticated_headers
    )
    
    # Unicode文字が適切に処理されることを確認
    assert response.status_code in [200, 500]  # 500はAzure OpenAI APIエラーの場合
```

## 3. パフォーマンステスト仕様

### 3.1 負荷テスト (test_performance.py)

#### 3.1.1 同時ユーザーテスト
```python
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor

def test_concurrent_user_registration(client, clean_user_store):
    """同時ユーザー登録テスト"""
    def register_user(user_id):
        user_data = {
            "username": f"user_{user_id}",
            "email": f"user_{user_id}@example.com",
            "password": "password123"
        }
        return client.post("/api/v1/auth/register", json=user_data)
    
    # 10人の同時ユーザー登録
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(register_user, i) for i in range(10)]
        results = [future.result() for future in futures]
    
    # すべての登録が成功することを確認
    success_count = sum(1 for result in results if result.status_code == 200)
    assert success_count == 10

def test_concurrent_login_attempts(client, clean_user_store):
    """同時ログイン試行テスト"""
    # テストユーザー作成
    user_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "password123"
    }
    client.post("/api/v1/auth/register", json=user_data)
    
    def login_user():
        login_data = {
            "username": "testuser",
            "password": "password123"
        }
        return client.post("/api/v1/auth/login", data=login_data)
    
    # 5回の同時ログイン
    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = [executor.submit(login_user) for _ in range(5)]
        results = [future.result() for future in futures]
    
    # すべてのログインが成功することを確認
    success_count = sum(1 for result in results if result.status_code == 200)
    assert success_count == 5

def test_concurrent_minutes_generation(client, clean_user_store):
    """同時議事録生成テスト"""
    # 複数のテストユーザー作成
    users = []
    for i in range(5):
        user_data = {
            "username": f"minutesuser_{i}",
            "email": f"minutesuser_{i}@example.com",
            "password": "password123"
        }
        client.post("/api/v1/auth/register", json=user_data)
        
        # ログインしてトークン取得
        login_response = client.post("/api/v1/auth/login", data={
            "username": user_data["username"],
            "password": user_data["password"]
        })
        token = login_response.json()["access_token"]
        users.append({"Authorization": f"Bearer {token}"})
    
    def generate_minutes(headers):
        transcript_data = {
            "meeting_title": "Concurrent Test Meeting",
            "meeting_date": "2024-01-15T10:00:00",
            "participants": ["Alice", "Bob"],
            "transcript_text": "Short transcript for concurrent testing",
        }
        return client.post("/api/v1/minutes/generate", json=transcript_data, headers=headers)
    
    # 5つの同時議事録生成
    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = [executor.submit(generate_minutes, user_headers) for user_headers in users]
        results = [future.result() for future in futures]
    
    # 結果の確認（成功またはAPIエラー）
    for result in results:
        assert result.status_code in [200, 500]  # 500はAzure OpenAI APIエラーの場合
```

#### 3.1.2 レスポンス時間テスト
```python
from unittest.mock import Mock, patch

@patch('src.modules.azure_openai_client.AzureOpenAI')
def test_minutes_generation_response_time(mock_azure_openai, client, authenticated_headers):
    """議事録生成レスポンス時間テスト"""
    # モックレスポンス設定
    mock_response = Mock()
    mock_response.choices[0].message.content = "Generated minutes"
    mock_azure_openai.return_value.chat.completions.create.return_value = mock_response
    
    transcript_data = {
        "meeting_title": "Performance Test Meeting",
        "meeting_date": "2024-01-15T10:00:00",
        "participants": ["Alice", "Bob"],
        "transcript_text": "Short transcript for performance testing",
    }
    
    start_time = time.time()
    response = client.post(
        "/api/v1/minutes/generate",
        json=transcript_data,
        headers=authenticated_headers
    )
    end_time = time.time()
    
    response_time = end_time - start_time
    
    assert response.status_code == 200
    assert response_time < 5.0  # 5秒以内のレスポンス

def test_authentication_response_time(client, test_user_data, clean_user_store):
    """認証レスポンス時間テスト"""
    # ユーザー登録
    client.post("/api/v1/auth/register", json=test_user_data)
    
    login_data = {
        "username": test_user_data["username"],
        "password": test_user_data["password"]
    }
    
    start_time = time.time()
    response = client.post("/api/v1/auth/login", data=login_data)
    end_time = time.time()
    
    response_time = end_time - start_time
    
    assert response.status_code == 200
    assert response_time < 1.0  # 1秒以内のレスポンス

def test_endpoint_response_times(client):
    """各エンドポイントのレスポンス時間テスト"""
    endpoints = [
        ("/", "GET"),
        ("/health", "GET"),
    ]
    
    for endpoint, method in endpoints:
        start_time = time.time()
        if method == "GET":
            response = client.get(endpoint)
        end_time = time.time()
        
        response_time = end_time - start_time
        
        assert response.status_code == 200
        assert response_time < 1.0  # 1秒以内のレスポンス
```

### 3.2 メモリ・リソーステスト
```python
import psutil
import os

def test_memory_usage_during_minutes_generation(client, authenticated_headers):
    """議事録生成時のメモリ使用量テスト"""
    process = psutil.Process(os.getpid())
    initial_memory = process.memory_info().rss / 1024 / 1024  # MB
    
    # 複数回の議事録生成
    for i in range(10):
        transcript_data = {
            "meeting_title": f"Memory Test Meeting {i}",
            "meeting_date": "2024-01-15T10:00:00",
            "participants": ["Alice", "Bob"],
            "transcript_text": f"Test transcript {i} " * 100,  # 適度なサイズ
        }
        
        response = client.post(
            "/api/v1/minutes/generate",
            json=transcript_data,
            headers=authenticated_headers
        )
    
    final_memory = process.memory_info().rss / 1024 / 1024  # MB
    memory_increase = final_memory - initial_memory
    
    # メモリ使用量の増加が許容範囲内であることを確認
    assert memory_increase < 100  # 100MB以下の増加
```

## 4. エラーハンドリングテスト仕様

### 4.1 例外処理テスト (test_error_handling.py)

#### 4.1.1 ネットワークエラーテスト
```python
@patch('src.modules.azure_openai_client.AzureOpenAI')
def test_azure_openai_network_error(mock_azure_openai, client, authenticated_headers):
    """Azure OpenAI ネットワークエラーテスト"""
    # ネットワークエラーをシミュレート
    mock_azure_openai.return_value.chat.completions.create.side_effect = ConnectionError("Network error")
    
    transcript_data = {
        "meeting_title": "Network Error Test",
        "meeting_date": "2024-01-15T10:00:00",
        "participants": ["Alice"],
        "transcript_text": "Test transcript",
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=transcript_data,
        headers=authenticated_headers
    )
    
    assert response.status_code == 500
    assert "Failed to generate meeting minutes" in response.json()["detail"]

@patch('src.modules.azure_openai_client.AzureOpenAI')
def test_azure_openai_timeout_error(mock_azure_openai, client, authenticated_headers):
    """Azure OpenAI タイムアウトエラーテスト"""
    # タイムアウトエラーをシミュレート
    mock_azure_openai.return_value.chat.completions.create.side_effect = TimeoutError("Request timeout")
    
    transcript_data = {
        "meeting_title": "Timeout Error Test",
        "meeting_date": "2024-01-15T10:00:00",
        "participants": ["Alice"],
        "transcript_text": "Test transcript",
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=transcript_data,
        headers=authenticated_headers
    )
    
    assert response.status_code == 500

@patch('src.modules.azure_openai_client.AzureOpenAI')
def test_azure_openai_rate_limit_error(mock_azure_openai, client, authenticated_headers):
    """Azure OpenAI レート制限エラーテスト"""
    # レート制限エラーをシミュレート
    from openai import RateLimitError
    mock_azure_openai.return_value.chat.completions.create.side_effect = RateLimitError("Rate limit exceeded")
    
    transcript_data = {
        "meeting_title": "Rate Limit Test",
        "meeting_date": "2024-01-15T10:00:00",
        "participants": ["Alice"],
        "transcript_text": "Test transcript",
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=transcript_data,
        headers=authenticated_headers
    )
    
    assert response.status_code == 429  # Too Many Requests
```

#### 4.1.2 データ形式エラーテスト
```python
def test_invalid_json_format(client, authenticated_headers):
    """無効なJSON形式テスト"""
    # 無効なJSONデータ
    invalid_json = '{"meeting_title": "Test", "invalid_json"}'
    
    response = client.post(
        "/api/v1/minutes/generate",
        data=invalid_json,
        headers={**authenticated_headers, "Content-Type": "application/json"}
    )
    
    assert response.status_code == 422

def test_missing_required_fields(client, authenticated_headers):
    """必須フィールド欠如テスト"""
    incomplete_data = {
        "meeting_title": "Test Meeting"
        # meeting_date, participants, transcript_text が欠如
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=incomplete_data,
        headers=authenticated_headers
    )
    
    assert response.status_code == 422

def test_invalid_date_format(client, authenticated_headers):
    """無効な日付形式テスト"""
    invalid_date_data = {
        "meeting_title": "Date Format Test",
        "meeting_date": "invalid-date-format",
        "participants": ["Alice"],
        "transcript_text": "Test transcript",
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=invalid_date_data,
        headers=authenticated_headers
    )
    
    assert response.status_code == 422

def test_empty_participants_list(client, authenticated_headers):
    """空の参加者リストテスト"""
    empty_participants_data = {
        "meeting_title": "Empty Participants Test",
        "meeting_date": "2024-01-15T10:00:00",
        "participants": [],
        "transcript_text": "Test transcript",
    }
    
    response = client.post(
        "/api/v1/minutes/generate",
        json=empty_participants_data,
        headers=authenticated_headers
    )
    
    assert response.status_code == 422
```

## 5. 継続的インテグレーション (CI) 設定

### 5.1 GitHub Actions設定例
```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        python-version: [3.8, 3.9, 3.10, 3.11]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v3
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Run tests with pytest
      run: |
        pytest --cov=src --cov-report=xml --cov-report=term
      env:
        AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
        AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Run security scan
      run: |
        pip install bandit safety
        bandit -r src/
        safety check --json
    
    - name: Run dependency check
      run: |
        pip install pip-audit
        pip-audit
```

### 5.2 テスト品質ゲート
```yaml
# .github/workflows/quality-gate.yml
name: Quality Gate

on:
  pull_request:
    branches: [ main ]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: 3.11
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Run quality checks
      run: |
        # カバレッジチェック（90%以上）
        pytest --cov=src --cov-fail-under=90
        
        # セキュリティテスト（100%パス）
        pytest tests/test_security.py -v
        
        # パフォーマンステスト
        pytest tests/test_performance.py -v
        
        # コード品質チェック
        flake8 src/ --max-line-length=100
        black --check src/
        isort --check-only src/
```

## 6. テスト品質指標

### 6.1 カバレッジ目標
- **コードカバレッジ**: 90%以上
- **ブランチカバレッジ**: 85%以上
- **関数カバレッジ**: 95%以上

### 6.2 パフォーマンス指標
- **API レスポンス時間**: 95%のリクエストが5秒以内
- **同時ユーザー数**: 100ユーザーまで対応
- **メモリ使用量**: 512MB以下

### 6.3 セキュリティ指標
- **認証テスト**: 100%パス
- **入力値検証テスト**: 100%パス
- **セキュリティ脆弱性**: 0件

### 6.4 信頼性指標
- **エラーハンドリングテスト**: 100%パス
- **例外処理カバレッジ**: 90%以上
- **障害復旧テスト**: 100%パス

## 7. テスト実行手順

### 7.1 総合テスト実行コマンド
```bash
# 全総合テスト実行
pytest tests/test_security.py tests/test_performance.py tests/test_error_handling.py tests/test_input_validation.py

# カバレッジ付き総合テスト実行
pytest --cov=src --cov-report=html --cov-report=term tests/test_security.py tests/test_performance.py tests/test_error_handling.py

# セキュリティテストのみ実行
pytest tests/test_security.py -v

# パフォーマンステストのみ実行
pytest tests/test_performance.py -v

# エラーハンドリングテストのみ実行
pytest tests/test_error_handling.py -v

# 並列テスト実行
pytest -n auto tests/test_performance.py
```

### 7.2 CI/CD統合テスト実行
```bash
# CI環境での全テスト実行
pytest --cov=src --cov-report=xml --cov-fail-under=90 --tb=short

# セキュリティスキャン実行
bandit -r src/ -f json -o security-report.json
safety check --json --output safety-report.json

# 品質チェック実行
flake8 src/ --output-file=flake8-report.txt
black --check src/
isort --check-only src/
```

## 8. テスト保守・更新

### 8.1 テストデータ管理
- テスト用ユーザーデータの定期更新
- モックデータの最新化
- テスト環境の定期リセット

### 8.2 テストケース追加指針
- 新機能追加時の対応テストケース作成
- バグ修正時の回帰テスト追加
- セキュリティ要件変更時のテスト更新

### 8.3 テスト結果分析
- 失敗テストの原因分析
- パフォーマンス劣化の監視
- カバレッジ低下の防止

### 8.4 セキュリティテスト更新
- 新しい脆弱性パターンの追加
- セキュリティベストプラクティスの反映
- 脅威モデルの定期見直し

## 9. 参考資料

- [FastAPI Testing Documentation](https://fastapi.tiangolo.com/tutorial/testing/)
- [pytest Documentation](https://docs.pytest.org/)
- [TestClient Documentation](https://fastapi.tiangolo.com/tutorial/testing/#using-testclient)
- [pytest-asyncio Documentation](https://pytest-asyncio.readthedocs.io/)
- [unittest.mock Documentation](https://docs.python.org/3/library/unittest.mock.html)
- [Security Testing Best Practices](https://owasp.org/www-project-web-security-testing-guide/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Python Security Best Practices](https://python.org/dev/security/)
- [Performance Testing Guidelines](https://docs.python.org/3/library/profile.html)
