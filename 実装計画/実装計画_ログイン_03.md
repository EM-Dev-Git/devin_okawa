# FastAPI ログイン認証システム 実装計画_ログイン_03 (アプリケーション全体保護版)

## 1. プロジェクト概要

### 1.1 目的
既存のFastAPI Azure OpenAI議事録生成システムに、アプリケーション全体を保護するJWTベースのログイン認証機能を構築する。
`http://localhost:8000` へのすべてのアクセスを認証必須とし、ミドルウェアベースの包括的なセキュリティを実現する。

### 1.2 主要機能
- アプリケーション全体のアクセス制御（ミドルウェアベース）
- ユーザー登録・ログイン・ログアウト機能（メモリ内辞書ベース）
- JWTトークンベース認証システム
- パスワードハッシュ化とセキュリティ機能
- 認証除外パスの設定機能
- メモリ内でのユーザーデータ管理

### 1.3 アプリケーション全体保護の利点
- **確実な保護**: 全URLが認証必須（デフォルトセキュア）
- **管理の簡素化**: 一箇所で認証制御
- **認証漏れ防止**: 新しいエンドポイントも自動的に保護
- **運用の安心**: デフォルトで保護、必要に応じて除外
- **集中管理**: ミドルウェアでの統一的な認証処理

### 1.4 実装計画_ログイン_02との違い
| 項目 | **実装計画_ログイン_02** | **実装計画_ログイン_03** |
|------|------------------------|------------------------|
| **保護範囲** | 特定エンドポイント | アプリケーション全体 |
| **実装方式** | Depends(get_current_user) | ミドルウェア |
| **保護対象** | `/api/v1/minutes/generate` | `http://localhost:8000/*` |
| **除外設定** | 不要 | 認証エンドポイントを除外 |
| **管理方法** | 各ルーターで個別設定 | main.pyで一括設定 |

## 2. システム構成

### 2.1 拡張ディレクトリ構造
```
/
├── src/
│   ├── config.py        # 設定管理（BaseSettings）※拡張
│   ├── modules/           # ビジネスロジック・処理モジュール
│   │   ├── azure_openai_client.py  # Azure OpenAI クライアント
│   │   ├── minutes_generator.py    # 議事録生成ロジック
│   │   ├── logger_config.py        # ログ設定
│   │   ├── auth.py       # 認証ユーティリティ（新規）
│   │   └── user_store.py # メモリ内ユーザー辞書管理（新規）
│   ├── middleware/       # FastAPI ミドルウェア（新規）
│   │   └── auth.py       # 認証ミドルウェア（新規）
│   ├── routers/          # FastAPI ルーター（エンドポイント定義）
│   │   ├── minutes.py    # 議事録生成エンドポイント※認証不要（ミドルウェアで保護）
│   │   └── auth.py       # 認証エンドポイント（新規）
│   ├── schemas/          # Pydantic データモデル
│   │   ├── transcript.py # トランスクリプトスキーマ
│   │   ├── minutes.py    # 議事録スキーマ
│   │   └── auth.py       # 認証スキーマ（新規）
│   ├── dependencies/     # FastAPI 依存関係（新規）
│   │   └── auth.py       # 認証依存関係（ミドルウェア用）
│   └── main.py          # FastAPI アプリケーションエントリーポイント※拡張
├── env/              # 環境設定ディレクトリ
│   ├── .env         # 環境変数設定ファイル（機密情報含む）※拡張
│   └── .env.example # 環境変数テンプレートファイル（機密情報除く）※拡張
├── requirements.txt # 依存関係※拡張
└── README.md        # プロジェクト説明※更新
```

### 2.2 技術スタック拡張
- **フレームワーク**: FastAPI（既存）
- **AI処理**: Azure OpenAI（既存）
- **認証**: JWT (PyJWT)
- **パスワードハッシュ**: bcrypt
- **データ管理**: メモリ内Python辞書（ファイルI/O不要）
- **ミドルウェア**: FastAPI HTTPミドルウェア
- **バリデーション**: Pydantic（既存）
- **設定管理**: pydantic-settings（既存）
- **ログ**: Python logging（既存）

## 3. 環境設定

### 3.1 依存関係追加
```txt
# requirements.txt に追加
PyJWT==2.8.0
bcrypt==4.1.2
python-multipart==0.0.6
```

### 3.2 環境変数設定

#### 3.2.1 env/.env（拡張）
```env
# Azure OpenAI設定（既存）
AZURE_OPENAI_API_KEY=your_azure_openai_api_key
AZURE_OPENAI_MODEL=gpt-4
AZURE_OPENAI_VERSION=2024-02-15-preview
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/

# JWT認証設定（新規）
JWT_SECRET_KEY=your_super_secret_jwt_key_here_change_in_production
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=30

# 認証除外パス設定（新規）
AUTH_EXCLUDED_PATHS=/api/v1/auth/login,/api/v1/auth/register,/health
```

#### 3.2.2 env/.env.example（拡張）
```env
# Azure OpenAI設定
AZURE_OPENAI_API_KEY=your_azure_openai_api_key
AZURE_OPENAI_MODEL=gpt-4
AZURE_OPENAI_VERSION=2024-02-15-preview
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/

# JWT認証設定
JWT_SECRET_KEY=your_super_secret_jwt_key_here_change_in_production
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=30

# 認証除外パス設定
AUTH_EXCLUDED_PATHS=/api/v1/auth/login,/api/v1/auth/register,/health
```

### 3.3 config.py拡張
```python
from pydantic_settings import BaseSettings
from typing import Optional, List

class Settings(BaseSettings):
    # Azure OpenAI設定（既存）
    azure_openai_api_key: str
    azure_openai_model: str
    azure_openai_version: str
    azure_openai_endpoint: str
    
    # JWT認証設定（新規）
    jwt_secret_key: str
    jwt_algorithm: str = "HS256"
    jwt_expire_minutes: int = 30
    
    # 認証除外パス設定（新規）
    auth_excluded_paths: str = "/api/v1/auth/login,/api/v1/auth/register,/health"
    
    @property
    def excluded_paths_list(self) -> List[str]:
        return [path.strip() for path in self.auth_excluded_paths.split(",")]
    
    class Config:
        env_file = "env/.env"

settings = Settings()
```

## 4. モジュール設計

### 4.1 認証ミドルウェア（新規）

#### 4.1.1 src/middleware/auth.py
```python
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from src.modules.auth import verify_access_token, JWTError
from src.config import settings
import logging

logger = logging.getLogger(__name__)

class AuthenticationMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.excluded_paths = settings.excluded_paths_list
        logger.info(f"Authentication middleware initialized with excluded paths: {self.excluded_paths}")

    async def dispatch(self, request: Request, call_next):
        # 除外パスのチェック
        if request.url.path in self.excluded_paths:
            logger.debug(f"Path {request.url.path} is excluded from authentication")
            return await call_next(request)
        
        # Authorizationヘッダーの取得
        authorization: str = request.headers.get("Authorization")
        
        if not authorization:
            logger.warning(f"Missing Authorization header for {request.url.path}")
            return JSONResponse(
                status_code=401,
                content={"detail": "Authorization header required"}
            )
        
        # Bearer トークンの検証
        try:
            scheme, token = authorization.split()
            if scheme.lower() != "bearer":
                raise ValueError("Invalid authentication scheme")
        except ValueError:
            logger.warning(f"Invalid Authorization header format for {request.url.path}")
            return JSONResponse(
                status_code=401,
                content={"detail": "Invalid authorization header format"}
            )
        
        # JWTトークンの検証
        try:
            payload = verify_access_token(token)
            username = payload.get("sub")
            if not username:
                raise JWTError("Invalid token payload")
            
            # リクエストにユーザー情報を追加
            request.state.current_user = username
            logger.debug(f"Authenticated user: {username} for {request.url.path}")
            
        except JWTError as e:
            logger.warning(f"JWT verification failed for {request.url.path}: {str(e)}")
            return JSONResponse(
                status_code=401,
                content={"detail": "Invalid or expired token"}
            )
        except Exception as e:
            logger.error(f"Authentication error for {request.url.path}: {str(e)}")
            return JSONResponse(
                status_code=500,
                content={"detail": "Authentication service error"}
            )
        
        # 認証成功、次のミドルウェア/エンドポイントへ
        return await call_next(request)
```

### 4.2 認証ユーティリティ（実装計画_ログイン_02から流用）

#### 4.2.1 src/modules/auth.py
```python
import bcrypt
import jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from src.config import settings
from src.modules.user_store import user_store
import logging

logger = logging.getLogger(__name__)

class JWTError(Exception):
    pass

def get_password_hash(password: str) -> str:
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return bcrypt.checkpw(
        plain_password.encode('utf-8'), 
        hashed_password.encode('utf-8')
    )

def create_access_token(data: Dict[str, Any]) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=settings.jwt_expire_minutes)
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(
        to_encode, 
        settings.jwt_secret_key, 
        algorithm=settings.jwt_algorithm
    )
    return encoded_jwt

def verify_access_token(token: str) -> Dict[str, Any]:
    try:
        payload = jwt.decode(
            token, 
            settings.jwt_secret_key, 
            algorithms=[settings.jwt_algorithm]
        )
        return payload
    except jwt.ExpiredSignatureError:
        raise JWTError("Token has expired")
    except jwt.JWTError:
        raise JWTError("Invalid token")

def authenticate_user(username: str, password: str) -> Optional[Dict[str, Any]]:
    user = user_store.get_user_by_username(username)
    if not user:
        return None
    
    if not verify_password(password, user['hashed_password']):
        return None
    
    return user

def get_user_by_username(username: str) -> Optional[Dict[str, Any]]:
    return user_store.get_user_by_username(username)

def get_user_by_email(email: str) -> Optional[Dict[str, Any]]:
    return user_store.get_user_by_email(email)

def create_user(username: str, email: str, password: str) -> Dict[str, Any]:
    hashed_password = get_password_hash(password)
    return user_store.create_user(username, email, hashed_password)
```

### 4.3 ユーザーストア（実装計画_ログイン_02から流用）

#### 4.3.1 src/modules/user_store.py
```python
from typing import Dict, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class UserStore:
    def __init__(self):
        self._users: Dict[str, Dict[str, Any]] = {}
        logger.info("UserStore initialized with empty memory dictionary")
    
    def create_user(self, username: str, email: str, hashed_password: str) -> Dict[str, Any]:
        user_data = {
            "username": username,
            "email": email,
            "hashed_password": hashed_password,
            "is_active": True,
            "created_at": datetime.utcnow().isoformat()
        }
        
        self._users[username] = user_data
        logger.info(f"User created: {username}")
        return {k: v for k, v in user_data.items() if k != 'hashed_password'}
    
    def get_user_by_username(self, username: str) -> Optional[Dict[str, Any]]:
        return self._users.get(username)
    
    def get_user_by_email(self, email: str) -> Optional[Dict[str, Any]]:
        for user in self._users.values():
            if user['email'] == email:
                return user
        return None
    
    def get_all_users(self) -> Dict[str, Dict[str, Any]]:
        return {k: {key: val for key, val in v.items() if key != 'hashed_password'} 
                for k, v in self._users.items()}
    
    def delete_user(self, username: str) -> bool:
        if username in self._users:
            del self._users[username]
            logger.info(f"User deleted: {username}")
            return True
        return False
    
    def update_user(self, username: str, **kwargs) -> Optional[Dict[str, Any]]:
        if username not in self._users:
            return None
        
        allowed_fields = ['email', 'is_active']
        for field, value in kwargs.items():
            if field in allowed_fields:
                self._users[username][field] = value
        
        logger.info(f"User updated: {username}")
        return {k: v for k, v in self._users[username].items() if k != 'hashed_password'}

user_store = UserStore()
```

### 4.4 認証スキーマ（実装計画_ログイン_02から流用）

#### 4.4.1 src/schemas/auth.py
```python
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

class UserCreate(BaseModel):
    username: str
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    username: str
    email: str
    is_active: bool
    created_at: str

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class UserLogin(BaseModel):
    username: str
    password: str
```

### 4.5 認証ルーター（実装計画_ログイン_02から流用）

#### 4.5.1 src/routers/auth.py
```python
from fastapi import APIRouter, HTTPException, Depends, status
from fastapi.security import OAuth2PasswordRequestForm
from src.schemas.auth import UserCreate, UserResponse, Token
from src.modules.auth import (
    authenticate_user, 
    create_access_token, 
    get_user_by_username, 
    get_user_by_email, 
    create_user
)
import logging

router = APIRouter(prefix="/api/v1/auth", tags=["authentication"])
logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register_user(user_data: UserCreate):
    try:
        if get_user_by_username(user_data.username):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already registered"
            )
        
        if get_user_by_email(user_data.email):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        user = create_user(
            username=user_data.username,
            email=user_data.email,
            password=user_data.password
        )
        
        logger.info(f"User registration successful: {user_data.username}")
        return UserResponse(**user)
        
    except Exception as e:
        logger.error(f"User registration failed: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Registration failed: {str(e)}"
        )

@router.post("/login", response_model=Token)
async def login_user(form_data: OAuth2PasswordRequestForm = Depends()):
    try:
        user = authenticate_user(form_data.username, form_data.password)
        if not user:
            logger.warning(f"Failed login attempt: {form_data.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        access_token = create_access_token(data={"sub": user['username']})
        logger.info(f"User login successful: {form_data.username}")
        
        return {"access_token": access_token, "token_type": "bearer"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Login failed: {str(e)}"
        )
```

### 4.6 main.py（拡張）
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from src.routers import minutes, auth
from src.modules.logger_config import setup_logger
from src.middleware.auth import AuthenticationMiddleware
import logging

setup_logger()
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Meeting Minutes Generator",
    description="Azure OpenAI powered meeting minutes generation system with application-wide authentication",
    version="2.0.0"
)

# CORS設定
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 認証ミドルウェア追加（重要：CORSの後に追加）
app.add_middleware(AuthenticationMiddleware)

# ルーター登録
app.include_router(auth.router)
app.include_router(minutes.router)

@app.get("/")
async def root():
    return {"message": "Meeting Minutes Generator API", "status": "running", "auth": "required"}

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "meeting-minutes-generator"}

if __name__ == "__main__":
    import uvicorn
    logger.info("Starting Meeting Minutes Generator API server with application-wide authentication")
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
```

## 5. 認証フロー

### 5.1 アプリケーション全体保護フロー
```
1. クライアント → http://localhost:8000/* (任意のURL)
2. AuthenticationMiddleware → リクエスト受信
3. 除外パスチェック → /api/v1/auth/*, /health は除外
4. Authorizationヘッダー確認 → Bearer トークン必須
5. JWTトークン検証 → 有効性・期限チェック
6. 認証成功 → request.state.current_user設定
7. 次のミドルウェア/エンドポイント → 通常処理
8. 認証失敗 → 401 Unauthorized返却
```

### 5.2 除外パス設定
```python
# デフォルト除外パス
excluded_paths = [
    "/api/v1/auth/login",    # ログインエンドポイント
    "/api/v1/auth/register", # ユーザー登録エンドポイント
    "/health"                # ヘルスチェック
]

# 環境変数で設定可能
AUTH_EXCLUDED_PATHS=/api/v1/auth/login,/api/v1/auth/register,/health
```

### 5.3 認証が必要なエンドポイント例
```
✅ 認証必須:
- http://localhost:8000/                    # ルートエンドポイント
- http://localhost:8000/api/v1/minutes/generate  # 議事録生成
- http://localhost:8000/docs                # Swagger UI
- http://localhost:8000/redoc               # ReDoc

❌ 認証除外:
- http://localhost:8000/api/v1/auth/login   # ログイン
- http://localhost:8000/api/v1/auth/register # ユーザー登録
- http://localhost:8000/health              # ヘルスチェック
```

## 6. セキュリティ考慮事項

### 6.1 ミドルウェアレベルのセキュリティ
- **デフォルトセキュア**: 新しいエンドポイントも自動的に保護
- **除外パス管理**: 最小限の除外パスのみ設定
- **トークン検証**: 全リクエストでJWT検証
- **エラーハンドリング**: 情報漏洩を防ぐエラーメッセージ

### 6.2 JWT セキュリティ
- **秘密鍵管理**: 環境変数での安全な管理
- **トークン有効期限**: 30分のデフォルト設定
- **アルゴリズム固定**: HS256の使用
- **ペイロード最小化**: 必要最小限の情報のみ

### 6.3 パスワードセキュリティ
- **bcryptハッシュ化**: ソルト付きハッシュ
- **平文保存禁止**: メモリ内でもハッシュ化済み
- **パスワード強度**: フロントエンドでの検証推奨

## 7. テスト戦略

### 7.1 ミドルウェアテスト
```python
# tests/test_auth_middleware.py
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

def test_protected_endpoint_without_token():
    response = client.get("/")
    assert response.status_code == 401
    assert response.json()["detail"] == "Authorization header required"

def test_excluded_path_access():
    response = client.get("/health")
    assert response.status_code == 200

def test_invalid_token_format():
    response = client.get("/", headers={"Authorization": "InvalidFormat"})
    assert response.status_code == 401
    assert "Invalid authorization header format" in response.json()["detail"]
```

### 7.2 統合テスト
```python
# tests/test_app_wide_auth.py
def test_full_authentication_flow():
    # ユーザー登録
    register_response = client.post("/api/v1/auth/register", json={
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123"
    })
    assert register_response.status_code == 200
    
    # ログイン
    login_response = client.post("/api/v1/auth/login", data={
        "username": "testuser",
        "password": "testpassword123"
    })
    assert login_response.status_code == 200
    token = login_response.json()["access_token"]
    
    # 保護されたエンドポイントアクセス
    protected_response = client.get("/", headers={
        "Authorization": f"Bearer {token}"
    })
    assert protected_response.status_code == 200
```

## 8. API使用例

### 8.1 ユーザー登録（認証不要）
```bash
curl -X POST "http://localhost:8000/api/v1/auth/register" \
     -H "Content-Type: application/json" \
     -d '{
       "username": "john_doe",
       "email": "john@example.com",
       "password": "securepassword123"
     }'
```

### 8.2 ログイン（認証不要）
```bash
curl -X POST "http://localhost:8000/api/v1/auth/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "username=john_doe&password=securepassword123"
```

### 8.3 ルートエンドポイントアクセス（認証必須）
```bash
curl -X GET "http://localhost:8000/" \
     -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

### 8.4 議事録生成API（認証必須）
```bash
curl -X POST "http://localhost:8000/api/v1/minutes/generate" \
     -H "Authorization: Bearer YOUR_JWT_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "meeting_title": "プロジェクト会議",
       "meeting_date": "2025-07-15T10:00:00",
       "participants": ["田中", "佐藤", "鈴木"],
       "transcript_text": "会議の内容..."
     }'
```

### 8.5 ヘルスチェック（認証不要）
```bash
curl -X GET "http://localhost:8000/health"
```

## 9. 運用・保守

### 9.1 ミドルウェア監視
- 認証失敗率の監視
- 除外パスアクセス状況
- トークン検証エラーの追跡
- パフォーマンス影響の監視

### 9.2 ログ管理
```python
# 認証ログの例
logger.info(f"Authenticated user: {username} for {request.url.path}")
logger.warning(f"Authentication failed for {request.url.path}: {error}")
logger.debug(f"Path {request.url.path} is excluded from authentication")
```

### 9.3 設定管理
- 除外パスの動的設定
- JWT有効期限の調整
- 秘密鍵のローテーション
- 環境別設定の管理

## 10. 将来の拡張計画

### 10.1 認証機能拡張
- ロールベースアクセス制御（RBAC）
- パス別権限設定
- ログイン試行回数制限
- セッション管理機能

### 10.2 ミドルウェア拡張
- レート制限ミドルウェア
- ログ記録ミドルウェア
- メトリクス収集ミドルウェア
- CORS設定の動的管理

### 10.3 永続化移行
- データベース統合
- Redis等のキャッシュ導入
- 分散環境対応
- マイクロサービス化

## 11. まとめ

この実装計画_ログイン_03では、FastAPIミドルウェアを使用してアプリケーション全体を保護するJWT認証システムを提案しています。

### 主な特徴：
- **包括的保護**: `http://localhost:8000` の全URLが認証必須
- **ミドルウェアベース**: 一箇所での統一的な認証制御
- **除外パス設定**: 認証エンドポイントとヘルスチェックは除外
- **メモリ内管理**: 最も簡単なユーザーデータ管理
- **デフォルトセキュア**: 新しいエンドポイントも自動的に保護

### 実装計画_ログイン_02との違い：
- **保護範囲**: 特定エンドポイント → アプリケーション全体
- **実装方式**: 依存性注入 → ミドルウェア
- **管理方法**: 分散管理 → 集中管理
- **セキュリティ**: 選択的保護 → 包括的保護

### 適用場面：
- 全体的なアクセス制御が必要な場合
- セキュリティを最優先とする環境
- 認証漏れを防ぎたい場合
- 統一的な認証ポリシーが必要な場合

この実装により、既存のFastAPI Azure OpenAI議事録生成システムに、最も確実で包括的な認証機能を追加し、アプリケーション全体のセキュリティを確保できます。
