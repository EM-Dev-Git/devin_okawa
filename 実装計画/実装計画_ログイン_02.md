# FastAPI ログイン認証システム 実装計画_ログイン_02 (ユーザー辞書版)

## 1. プロジェクト概要

### 1.1 目的
既存のFastAPI Azure OpenAI議事録生成システムにJWTベースのログイン認証機能を構築する。
データベースを使用せず、シンプルなユーザー辞書（メモリ内またはJSONファイル）でユーザー管理を実現し、セキュアなAPIアクセスを提供する。

### 1.2 主要機能
- ユーザー登録・ログイン・ログアウト機能（ユーザー辞書ベース）
- JWTトークンベース認証システム
- パスワードハッシュ化とセキュリティ機能
- 既存議事録生成APIの認証保護
- ユーザープロファイル管理
- JSONファイルによるユーザーデータ永続化

### 1.3 データベース不要の利点
- 簡単なセットアップ（SQLAlchemy、Alembic不要）
- 軽量な実装
- 開発・テスト環境での迅速な動作確認
- 外部依存関係の削減

## 2. システム構成

### 2.1 拡張ディレクトリ構造
```
/
├── src/
│   ├── modules/           # ビジネスロジック・処理モジュール
│   │   ├── config.py     # 設定管理（BaseSettings）※拡張
│   │   ├── azure_openai_client.py  # Azure OpenAI クライアント
│   │   ├── minutes_generator.py    # 議事録生成ロジック
│   │   ├── logger_config.py        # ログ設定
│   │   ├── auth.py       # 認証ユーティリティ（新規）
│   │   └── user_store.py # ユーザー辞書管理（新規）
│   ├── routers/          # FastAPI ルーター（エンドポイント定義）
│   │   ├── minutes.py    # 議事録生成エンドポイント※認証保護追加
│   │   └── auth.py       # 認証エンドポイント（新規）
│   ├── schemas/          # Pydantic データモデル
│   │   ├── transcript.py # トランスクリプトスキーマ
│   │   ├── minutes.py    # 議事録スキーマ
│   │   └── auth.py       # 認証スキーマ（新規）
│   ├── dependencies/     # FastAPI 依存関係（新規）
│   │   └── auth.py       # 認証依存関係
│   ├── data/             # データファイル（新規）
│   │   └── users.json    # ユーザーデータファイル
│   └── main.py          # FastAPI アプリケーションエントリーポイント※拡張
├── env/              # 環境設定ディレクトリ
│   ├── .env         # 環境変数設定ファイル（機密情報含む）※拡張
│   └── .env.example # 環境変数テンプレートファイル（機密情報除く）※拡張
├── requirements.txt # 依存関係※拡張
└── README.md        # プロジェクト説明※更新
```

### 2.2 技術スタック拡張
- **フレームワーク**: FastAPI（既存）
- **AI処理**: Azure OpenAI（既存）
- **認証**: JWT (PyJWT)
- **パスワードハッシュ**: bcrypt
- **データ永続化**: JSON ファイル（SQLAlchemy不要）
- **バリデーション**: Pydantic（既存）
- **設定管理**: pydantic-settings（既存）
- **ログ**: Python logging（既存）

## 3. 環境設定

### 3.1 依存関係追加
```txt
# requirements.txt に追加
PyJWT==2.8.0
bcrypt==4.1.2
python-multipart==0.0.6
```

### 3.2 環境変数設定

#### 3.2.1 env/.env（拡張）
```env
# Azure OpenAI設定（既存）
AZURE_OPENAI_API_KEY=your_azure_openai_api_key
AZURE_OPENAI_MODEL=gpt-4
AZURE_OPENAI_VERSION=2024-02-15-preview
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/

# JWT認証設定（新規）
JWT_SECRET_KEY=your_super_secret_jwt_key_here_change_in_production
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=30

# ユーザーデータファイル設定（新規）
USERS_DATA_FILE=src/data/users.json
```

#### 3.2.2 env/.env.example（拡張）
```env
# Azure OpenAI設定
AZURE_OPENAI_API_KEY=your_azure_openai_api_key
AZURE_OPENAI_MODEL=gpt-4
AZURE_OPENAI_VERSION=2024-02-15-preview
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/

# JWT認証設定
JWT_SECRET_KEY=your_super_secret_jwt_key_here_change_in_production
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=30

# ユーザーデータファイル設定
USERS_DATA_FILE=src/data/users.json
```

## 4. モジュール設計

### 4.1 schemas/ - データモデル拡張

#### 4.1.1 schemas/auth.py（新規）
```python
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class UserResponse(UserBase):
    id: str
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
```

### 4.2 modules/ - ビジネスロジック拡張

#### 4.2.1 modules/config.py（拡張）
```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # Azure OpenAI設定（既存）
    azure_openai_api_key: str
    azure_openai_model: str
    azure_openai_version: str
    azure_openai_endpoint: str
    
    # JWT認証設定（新規）
    jwt_secret_key: str
    jwt_algorithm: str = "HS256"
    jwt_expire_minutes: int = 30
    
    # ユーザーデータファイル設定（新規）
    users_data_file: str = "src/data/users.json"
    
    class Config:
        env_file = "env/.env"

settings = Settings()
```

#### 4.2.2 modules/user_store.py（新規）
```python
import json
import os
import uuid
from datetime import datetime
from typing import Dict, Optional, List
from src.modules.config import settings

class UserStore:
    def __init__(self):
        self.data_file = settings.users_data_file
        self._ensure_data_file()
    
    def _ensure_data_file(self):
        """データファイルとディレクトリが存在することを確認"""
        os.makedirs(os.path.dirname(self.data_file), exist_ok=True)
        if not os.path.exists(self.data_file):
            self._save_users({})
    
    def _load_users(self) -> Dict:
        """ユーザーデータをJSONファイルから読み込み"""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return {}
    
    def _save_users(self, users: Dict):
        """ユーザーデータをJSONファイルに保存"""
        with open(self.data_file, 'w', encoding='utf-8') as f:
            json.dump(users, f, ensure_ascii=False, indent=2, default=str)
    
    def get_user_by_username(self, username: str) -> Optional[Dict]:
        """ユーザー名でユーザーを取得"""
        users = self._load_users()
        return users.get(username)
    
    def get_user_by_email(self, email: str) -> Optional[Dict]:
        """メールアドレスでユーザーを取得"""
        users = self._load_users()
        for user_data in users.values():
            if user_data.get('email') == email:
                return user_data
        return None
    
    def create_user(self, username: str, email: str, hashed_password: str) -> Dict:
        """新しいユーザーを作成"""
        users = self._load_users()
        
        user_id = str(uuid.uuid4())
        user_data = {
            'id': user_id,
            'username': username,
            'email': email,
            'hashed_password': hashed_password,
            'is_active': True,
            'created_at': datetime.utcnow().isoformat(),
            'updated_at': datetime.utcnow().isoformat()
        }
        
        users[username] = user_data
        self._save_users(users)
        return user_data
    
    def update_user(self, username: str, **kwargs) -> Optional[Dict]:
        """ユーザー情報を更新"""
        users = self._load_users()
        if username not in users:
            return None
        
        users[username].update(kwargs)
        users[username]['updated_at'] = datetime.utcnow().isoformat()
        self._save_users(users)
        return users[username]
    
    def delete_user(self, username: str) -> bool:
        """ユーザーを削除"""
        users = self._load_users()
        if username in users:
            del users[username]
            self._save_users(users)
            return True
        return False
    
    def list_users(self) -> List[Dict]:
        """全ユーザーのリストを取得"""
        users = self._load_users()
        return list(users.values())

# グローバルインスタンス
user_store = UserStore()
```

#### 4.2.3 modules/auth.py（新規）
```python
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from src.modules.config import settings
from src.modules.user_store import user_store
from src.schemas.auth import TokenData

# パスワードハッシュ化設定
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """パスワードを検証"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """パスワードをハッシュ化"""
    return pwd_context.hash(password)

def authenticate_user(username: str, password: str):
    """ユーザー認証"""
    user = user_store.get_user_by_username(username)
    if not user:
        return False
    if not verify_password(password, user['hashed_password']):
        return False
    return user

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """JWTアクセストークンを作成"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.jwt_expire_minutes)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)
    return encoded_jwt

def verify_token(token: str, credentials_exception):
    """JWTトークンを検証"""
    try:
        payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    return token_data

def get_user_by_username(username: str):
    """ユーザー名でユーザーを取得"""
    return user_store.get_user_by_username(username)

def get_user_by_email(email: str):
    """メールアドレスでユーザーを取得"""
    return user_store.get_user_by_email(email)

def create_user(username: str, email: str, password: str):
    """新しいユーザーを作成"""
    hashed_password = get_password_hash(password)
    return user_store.create_user(username, email, hashed_password)
```

### 4.3 dependencies/ - 依存関係

#### 4.3.1 dependencies/auth.py（新規）
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from src.modules.auth import verify_token, get_user_by_username

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/v1/auth/login")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    token_data = verify_token(token, credentials_exception)
    user = get_user_by_username(username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: dict = Depends(get_current_user)):
    if not current_user.get('is_active'):
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user
```

### 4.4 routers/ - エンドポイント拡張

#### 4.4.1 routers/auth.py（新規）
```python
from fastapi import APIRouter, HTTPException, Depends, status
from fastapi.security import OAuth2PasswordRequestForm
from src.schemas.auth import UserCreate, UserResponse, Token, UserLogin
from src.modules.auth import (
    authenticate_user, 
    create_access_token, 
    get_user_by_username, 
    get_user_by_email, 
    create_user
)
from src.dependencies.auth import get_current_active_user
import logging

router = APIRouter(prefix="/api/v1/auth", tags=["authentication"])
logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register_user(user_data: UserCreate):
    try:
        # ユーザー名重複チェック
        if get_user_by_username(user_data.username):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already registered"
            )
        
        # メールアドレス重複チェック
        if get_user_by_email(user_data.email):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        # ユーザー作成
        user = create_user(
            username=user_data.username,
            email=user_data.email,
            password=user_data.password
        )
        
        logger.info(f"User registration successful: {user_data.username}")
        return UserResponse(**user)
        
    except Exception as e:
        logger.error(f"User registration failed: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Registration failed: {str(e)}"
        )

@router.post("/login", response_model=Token)
async def login_user(form_data: OAuth2PasswordRequestForm = Depends()):
    try:
        user = authenticate_user(form_data.username, form_data.password)
        if not user:
            logger.warning(f"Failed login attempt: {form_data.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        access_token = create_access_token(data={"sub": user['username']})
        logger.info(f"User login successful: {form_data.username}")
        
        return {"access_token": access_token, "token_type": "bearer"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Login failed: {str(e)}"
        )

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: dict = Depends(get_current_active_user)):
    return UserResponse(**current_user)

@router.post("/logout")
async def logout_user(current_user: dict = Depends(get_current_active_user)):
    logger.info(f"User logout: {current_user['username']}")
    return {"message": "Successfully logged out"}
```

#### 4.4.2 routers/minutes.py（認証保護追加）
```python
from fastapi import APIRouter, HTTPException, Depends
from src.schemas.transcript import TranscriptInput
from src.schemas.minutes import MinutesOutput
from src.modules.minutes_generator import MinutesGenerator
from src.dependencies.auth import get_current_active_user
import logging

router = APIRouter(prefix="/api/v1/minutes", tags=["minutes"])
logger = logging.getLogger(__name__)

@router.post("/generate", response_model=MinutesOutput)
async def generate_meeting_minutes(
    transcript_data: TranscriptInput,
    current_user: dict = Depends(get_current_active_user)
):
    try:
        logger.info(f"Received authenticated request to generate minutes for: {transcript_data.meeting_title} by user: {current_user['username']}")
        
        generator = MinutesGenerator()
        minutes = generator.generate_minutes(transcript_data)
        
        logger.info(f"Minutes generation request completed successfully for user: {current_user['username']}")
        return minutes
        
    except Exception as e:
        logger.error(f"Error generating meeting minutes for user {current_user['username']}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate meeting minutes: {str(e)}"
        )
```

### 4.5 main.py（拡張）
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from src.routers import minutes, auth
from src.modules.logger_config import setup_logging
import logging

# ログ設定
setup_logging()
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Meeting Minutes Generator with Authentication",
    description="Azure OpenAI を使用した議事録生成システム（JWT認証付き）",
    version="2.0.0"
)

# CORS設定
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ルーター登録
app.include_router(auth.router)  # 認証ルーター（新規）
app.include_router(minutes.router)  # 議事録ルーター（認証保護済み）

@app.get("/")
async def root():
    return {
        "message": "Meeting Minutes Generator API with Authentication",
        "version": "2.0.0",
        "features": [
            "JWT Authentication",
            "User Registration & Login",
            "Azure OpenAI Integration",
            "Meeting Minutes Generation"
        ]
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy", "authentication": "enabled"}

if __name__ == "__main__":
    import uvicorn
    logger.info("Starting Meeting Minutes Generator API with Authentication...")
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## 5. データファイル初期化

### 5.1 src/data/users.json（初期ファイル）
```json
{}
```

## 6. 実装手順

### 6.1 フェーズ1: 依存関係とデータ構造準備
1. **依存関係インストール**
   ```bash
   pip install PyJWT==2.8.0 bcrypt==4.1.2 python-multipart==0.0.6
   ```

2. **ディレクトリ作成**
   ```bash
   mkdir -p src/data src/dependencies
   ```

3. **環境変数設定**
   - `env/.env` にJWT設定を追加
   - `env/.env.example` を更新

### 6.2 フェーズ2: ユーザーストア実装
1. **modules/user_store.py** 作成
2. **modules/config.py** 拡張
3. **src/data/users.json** 初期化

### 6.3 フェーズ3: 認証システム実装
1. **modules/auth.py** 作成
2. **schemas/auth.py** 作成
3. **dependencies/auth.py** 作成

### 6.4 フェーズ4: 認証APIエンドポイント実装
1. **routers/auth.py** 作成
2. **routers/minutes.py** 認証保護追加

### 6.5 フェーズ5: アプリケーション統合
1. **main.py** 拡張
2. **requirements.txt** 更新

### 6.6 フェーズ6: テスト・検証
1. ユーザー登録テスト
2. ログインテスト
3. 認証保護されたAPIテスト
4. エラーハンドリングテスト

## 7. セキュリティ考慮事項

### 7.1 パスワードセキュリティ
- bcryptによる強力なパスワードハッシュ化
- ソルト自動生成
- レインボーテーブル攻撃対策

### 7.2 JWTトークンセキュリティ
- 強力な秘密鍵の使用
- トークン有効期限設定
- 適切なアルゴリズム選択（HS256）

### 7.3 データファイルセキュリティ
- JSONファイルの適切な権限設定
- 機密情報の環境変数管理
- バックアップとリストア戦略

### 7.4 エラーハンドリング
- 情報漏洩を防ぐエラーメッセージ
- ログイン試行回数制限（将来実装）
- 適切なHTTPステータスコード

## 8. テスト戦略

### 8.1 ユニットテスト
```python
# tests/test_auth.py
import pytest
from src.modules.auth import verify_password, get_password_hash, create_access_token
from src.modules.user_store import UserStore

def test_password_hashing():
    password = "testpassword123"
    hashed = get_password_hash(password)
    assert verify_password(password, hashed)
    assert not verify_password("wrongpassword", hashed)

def test_user_store():
    store = UserStore()
    user = store.create_user("testuser", "test@example.com", "hashedpassword")
    assert user['username'] == "testuser"
    assert store.get_user_by_username("testuser") is not None
```

### 8.2 統合テスト
```python
# tests/test_auth_endpoints.py
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

def test_register_user():
    response = client.post("/api/v1/auth/register", json={
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123"
    })
    assert response.status_code == 200
    assert response.json()["username"] == "testuser"

def test_login_user():
    # 先にユーザー登録
    client.post("/api/v1/auth/register", json={
        "username": "logintest",
        "email": "login@example.com",
        "password": "testpassword123"
    })
    
    # ログインテスト
    response = client.post("/api/v1/auth/login", data={
        "username": "logintest",
        "password": "testpassword123"
    })
    assert response.status_code == 200
    assert "access_token" in response.json()
```

## 9. API使用例

### 9.1 ユーザー登録
```bash
curl -X POST "http://localhost:8000/api/v1/auth/register" \
     -H "Content-Type: application/json" \
     -d '{
       "username": "john_doe",
       "email": "john@example.com",
       "password": "securepassword123"
     }'
```

### 9.2 ログイン
```bash
curl -X POST "http://localhost:8000/api/v1/auth/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "username=john_doe&password=securepassword123"
```

### 9.3 認証が必要なAPI呼び出し
```bash
curl -X POST "http://localhost:8000/api/v1/minutes/generate" \
     -H "Authorization: Bearer YOUR_JWT_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "meeting_title": "プロジェクト会議",
       "meeting_date": "2025-07-15T10:00:00",
       "participants": ["田中", "佐藤", "鈴木"],
       "transcript_text": "会議の内容..."
     }'
```

## 10. 運用・保守

### 10.1 ユーザーデータ管理
- JSONファイルの定期バックアップ
- ユーザーデータの整合性チェック
- 不要ユーザーの削除機能

### 10.2 ログ監視
- 認証試行ログの監視
- 異常なアクセスパターンの検出
- パフォーマンス監視

### 10.3 セキュリティ更新
- 依存関係の定期更新
- セキュリティパッチの適用
- JWT秘密鍵のローテーション

## 11. 将来の拡張計画

### 11.1 機能拡張
- パスワードリセット機能
- ユーザーロール・権限管理
- ログイン試行回数制限
- セッション管理

### 11.2 データベース移行準備
- ユーザーデータのデータベース移行ツール
- SQLAlchemyモデルとの互換性維持
- データマイグレーション戦略

### 11.3 スケーラビリティ
- Redis等のキャッシュ導入
- 分散環境での認証
- マイクロサービス化対応

## 12. まとめ

この実装計画_ログイン_02では、データベースを使用せずにシンプルなユーザー辞書（JSONファイル）を使用したJWT認証システムを提案しています。

### 主な利点：
- **簡単なセットアップ**: データベース設定不要
- **軽量な実装**: 最小限の依存関係
- **迅速な開発**: 複雑なORM設定不要
- **テスト容易性**: ファイルベースでテストが簡単

### 適用場面：
- プロトタイプ開発
- 小規模システム
- 開発・テスト環境
- データベース制約がある環境

この実装により、既存のFastAPI Azure OpenAI議事録生成システムに、データベース不要の認証機能を迅速に追加できます。
