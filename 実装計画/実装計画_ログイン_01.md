# FastAPI ログイン認証システム 実装計画_ログイン_01

## 1. プロジェクト概要

### 1.1 目的
既存のFastAPI Azure OpenAI議事録生成システムにJWTベースのログイン認証機能を構築する。
ユーザー管理、認証、認可機能を追加し、セキュアなAPIアクセスを実現する。

### 1.2 主要機能
- ユーザー登録・ログイン・ログアウト機能
- JWTトークンベース認証システム
- パスワードハッシュ化とセキュリティ機能
- 既存議事録生成APIの認証保護
- ユーザープロファイル管理
- SQLAlchemyによるユーザーデータ永続化

## 2. システム構成

### 2.1 拡張ディレクトリ構造
```
/
├── src/
│   ├── modules/           # ビジネスロジック・処理モジュール
│   │   ├── config.py     # 設定管理（BaseSettings）※拡張
│   │   ├── azure_openai_client.py  # Azure OpenAI クライアント
│   │   ├── minutes_generator.py    # 議事録生成ロジック
│   │   ├── logger_config.py        # ログ設定
│   │   ├── auth.py       # 認証ユーティリティ（新規）
│   │   └── database.py   # データベース設定・モデル（新規）
│   ├── routers/          # FastAPI ルーター（エンドポイント定義）
│   │   ├── minutes.py    # 議事録生成エンドポイント※認証保護追加
│   │   └── auth.py       # 認証エンドポイント（新規）
│   ├── schemas/          # Pydantic データモデル
│   │   ├── transcript.py # トランスクリプトスキーマ
│   │   ├── minutes.py    # 議事録スキーマ
│   │   └── auth.py       # 認証スキーマ（新規）
│   ├── dependencies/     # FastAPI 依存関係（新規）
│   │   └── auth.py       # 認証依存関係
│   └── main.py          # FastAPI アプリケーションエントリーポイント※拡張
├── env/              # 環境設定ディレクトリ
│   ├── .env         # 環境変数設定ファイル（機密情報含む）※拡張
│   └── .env.example # 環境変数テンプレートファイル（機密情報除く）※拡張
├── alembic/         # データベースマイグレーション（新規）
├── requirements.txt # 依存関係※拡張
└── README.md        # プロジェクト説明※更新
```

### 2.2 技術スタック拡張
- **フレームワーク**: FastAPI（既存）
- **AI処理**: Azure OpenAI（既存）
- **データ検証**: Pydantic（既存）
- **ログ**: Python標準logging（既存）
- **環境管理**: python-dotenv（既存）
- **認証**: JWT (PyJWT)（新規）
- **データベース**: SQLAlchemy + SQLite/PostgreSQL（新規）
- **パスワードハッシュ**: bcrypt（新規）
- **マイグレーション**: Alembic（新規）

## 3. 環境設定拡張

### 3.1 env/.env ファイル拡張構成
```env
# Azure OpenAI API設定（既存）
azure_openai_api_key=your_azure_openai_api_key_here
azure_openai_model=gpt-4
azure_openai_version=2024-02-15-preview
azure_openai_endpoint=https://your-resource.openai.azure.com/

# JWT認証設定（新規）
jwt_secret_key=your_super_secret_jwt_key_here_minimum_32_characters
jwt_algorithm=HS256
jwt_expire_minutes=30

# データベース設定（新規）
database_url=sqlite:///./meeting_minutes.db
```

### 3.2 env/.env.example ファイル拡張構成
```env
# Azure OpenAI API設定
azure_openai_api_key=your_azure_openai_api_key_here
azure_openai_model=gpt-4
azure_openai_version=2024-02-15-preview
azure_openai_endpoint=https://your-resource.openai.azure.com/

# JWT認証設定
jwt_secret_key=your_super_secret_jwt_key_here_minimum_32_characters
jwt_algorithm=HS256
jwt_expire_minutes=30

# データベース設定
database_url=sqlite:///./meeting_minutes.db
```

### 3.3 新規環境変数仕様
- **jwt_secret_key**: JWT署名用秘密鍵（文字列、最低32文字）
- **jwt_algorithm**: JWT署名アルゴリズム（文字列、デフォルト: HS256）
- **jwt_expire_minutes**: JWTトークン有効期限（整数、分単位）
- **database_url**: データベース接続URL（文字列）

## 4. モジュール設計

### 4.1 schemas/ - データモデル拡張

#### 4.1.1 schemas/auth.py（新規）
```python
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class UserResponse(UserBase):
    id: int
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
```

### 4.2 modules/ - ビジネスロジック拡張

#### 4.2.1 modules/config.py（拡張）
```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # Azure OpenAI設定（既存）
    azure_openai_api_key: str
    azure_openai_model: str
    azure_openai_version: str
    azure_openai_endpoint: str
    
    # JWT認証設定（新規）
    jwt_secret_key: str
    jwt_algorithm: str = "HS256"
    jwt_expire_minutes: int = 30
    
    # データベース設定（新規）
    database_url: str = "sqlite:///./meeting_minutes.db"
    
    class Config:
        env_file = "env/.env"

settings = Settings()
```

#### 4.2.2 modules/database.py（新規）
```python
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
from .config import settings

engine = create_engine(settings.database_url)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def create_tables():
    Base.metadata.create_all(bind=engine)
```

#### 4.2.3 modules/auth.py（新規）
```python
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from .config import settings
from .database import User
import logging

logger = logging.getLogger(__name__)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.jwt_expire_minutes)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)
    return encoded_jwt

def verify_token(token: str) -> Optional[str]:
    try:
        payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
        username: str = payload.get("sub")
        if username is None:
            return None
        return username
    except JWTError:
        return None

def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    user = db.query(User).filter(User.username == username).first()
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user

def create_user(db: Session, username: str, email: str, password: str) -> User:
    hashed_password = get_password_hash(password)
    db_user = User(
        username=username,
        email=email,
        hashed_password=hashed_password
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    logger.info(f"New user created: {username}")
    return db_user

def get_user_by_username(db: Session, username: str) -> Optional[User]:
    return db.query(User).filter(User.username == username).first()

def get_user_by_email(db: Session, email: str) -> Optional[User]:
    return db.query(User).filter(User.email == email).first()
```

### 4.3 dependencies/ - 認証依存関係（新規）

#### 4.3.1 dependencies/auth.py（新規）
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from src.modules.auth import verify_token, get_user_by_username
from src.modules.database import get_db, User
import logging

logger = logging.getLogger(__name__)

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    token = credentials.credentials
    username = verify_token(token)
    
    if username is None:
        logger.warning("Invalid token provided")
        raise credentials_exception
    
    user = get_user_by_username(db, username=username)
    if user is None:
        logger.warning(f"User not found: {username}")
        raise credentials_exception
    
    if not user.is_active:
        logger.warning(f"Inactive user attempted access: {username}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user
```

### 4.4 routers/ - API エンドポイント拡張

#### 4.4.1 routers/auth.py（新規）
```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer
from sqlalchemy.orm import Session
from src.schemas.auth import UserCreate, UserLogin, UserResponse, Token
from src.modules.database import get_db
from src.modules.auth import (
    authenticate_user, 
    create_user, 
    create_access_token,
    get_user_by_username,
    get_user_by_email
)
from src.dependencies.auth import get_current_active_user
import logging

router = APIRouter(prefix="/api/v1/auth", tags=["authentication"])
logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register_user(user_data: UserCreate, db: Session = Depends(get_db)):
    try:
        # ユーザー名重複チェック
        if get_user_by_username(db, user_data.username):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already registered"
            )
        
        # メールアドレス重複チェック
        if get_user_by_email(db, user_data.email):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        # ユーザー作成
        user = create_user(
            db=db,
            username=user_data.username,
            email=user_data.email,
            password=user_data.password
        )
        
        logger.info(f"User registration successful: {user_data.username}")
        return user
        
    except Exception as e:
        logger.error(f"User registration failed: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Registration failed: {str(e)}"
        )

@router.post("/login", response_model=Token)
async def login_user(user_credentials: UserLogin, db: Session = Depends(get_db)):
    try:
        user = authenticate_user(db, user_credentials.username, user_credentials.password)
        if not user:
            logger.warning(f"Failed login attempt: {user_credentials.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        access_token = create_access_token(data={"sub": user.username})
        logger.info(f"User login successful: {user_credentials.username}")
        
        return {"access_token": access_token, "token_type": "bearer"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Login failed: {str(e)}"
        )

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user = Depends(get_current_active_user)):
    return current_user

@router.post("/logout")
async def logout_user(current_user = Depends(get_current_active_user)):
    logger.info(f"User logout: {current_user.username}")
    return {"message": "Successfully logged out"}
```

#### 4.4.2 routers/minutes.py（認証保護追加）
```python
from fastapi import APIRouter, HTTPException, Depends
from src.schemas.transcript import TranscriptInput
from src.schemas.minutes import MinutesOutput
from src.modules.minutes_generator import MinutesGenerator
from src.dependencies.auth import get_current_active_user
from src.modules.database import User
import logging

router = APIRouter(prefix="/api/v1/minutes", tags=["minutes"])
logger = logging.getLogger(__name__)

@router.post("/generate", response_model=MinutesOutput)
async def generate_meeting_minutes(
    transcript_data: TranscriptInput,
    current_user: User = Depends(get_current_active_user)
):
    try:
        logger.info(f"Received authenticated request to generate minutes for: {transcript_data.meeting_title} by user: {current_user.username}")
        
        generator = MinutesGenerator()
        minutes = generator.generate_minutes(transcript_data)
        
        logger.info(f"Minutes generation request completed successfully for user: {current_user.username}")
        return minutes
        
    except Exception as e:
        logger.error(f"Error generating meeting minutes for user {current_user.username}: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate meeting minutes: {str(e)}"
        )
```

### 4.5 main.py（拡張）
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .routers.minutes import router as minutes_router
from .routers.auth import router as auth_router
from .modules.logger_config import setup_logger
from .modules.database import create_tables
import logging

setup_logger()
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Meeting Minutes Generator with Authentication",
    description="Azure OpenAI powered meeting minutes generation system with JWT authentication",
    version="2.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# データベーステーブル作成
create_tables()

# ルーター登録
app.include_router(auth_router)
app.include_router(minutes_router)

@app.get("/")
async def root():
    return {
        "message": "Meeting Minutes Generator API with Authentication", 
        "status": "running",
        "version": "2.0.0"
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "meeting-minutes-generator-auth"}

if __name__ == "__main__":
    import uvicorn
    logger.info("Starting Meeting Minutes Generator API server with authentication")
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
```

## 5. 実装手順

### 5.1 フェーズ1: 依存関係とデータベース基盤構築
1. requirements.txt に新規依存関係追加
   - `python-jose[cryptography]`
   - `passlib[bcrypt]`
   - `sqlalchemy`
   - `alembic`
   - `python-multipart`
2. modules/database.py 実装（SQLAlchemy設定・Userモデル）
3. データベース初期化テスト
4. Alembicマイグレーション設定

### 5.2 フェーズ2: 認証システム実装
1. modules/config.py 拡張（JWT・DB設定追加）
2. modules/auth.py 実装（認証ユーティリティ）
3. schemas/auth.py 実装（認証データモデル）
4. 認証機能単体テスト

### 5.3 フェーズ3: 認証依存関係実装
1. dependencies/auth.py 実装（FastAPI依存関係）
2. 認証依存関係テスト
3. トークン検証機能テスト

### 5.4 フェーズ4: 認証API エンドポイント実装
1. routers/auth.py 実装（登録・ログイン・プロファイル）
2. 認証エンドポイント統合テスト
3. エラーハンドリング実装

### 5.5 フェーズ5: 既存API認証保護
1. routers/minutes.py 認証保護追加
2. 既存機能の認証統合テスト
3. 認証フロー全体テスト

### 5.6 フェーズ6: アプリケーション統合
1. main.py 拡張（認証ルーター追加・DB初期化）
2. 環境設定ファイル更新
3. 統合テスト実行

### 5.7 フェーズ7: テスト・検証・ドキュメント
1. 包括的テストスイート実装
2. セキュリティテスト実行
3. API ドキュメント更新
4. パフォーマンステスト

## 6. セキュリティ考慮事項

### 6.1 認証セキュリティ
- **パスワードハッシュ化**: bcryptによる安全なハッシュ化
- **JWT署名**: HS256アルゴリズムによる署名検証
- **トークン有効期限**: 30分のデフォルト有効期限
- **秘密鍵管理**: 環境変数による秘密鍵管理

### 6.2 API セキュリティ
- **入力検証**: Pydanticによる厳密なデータ検証
- **SQLインジェクション対策**: SQLAlchemy ORMによる対策
- **認証必須**: 議事録生成APIの認証必須化
- **CORS設定**: 適切なCORS設定

### 6.3 データ保護
- **機密情報分離**: env/.env.exampleでの機密情報除去
- **データベース暗号化**: パスワードハッシュ化保存
- **ログ管理**: 機密情報のログ出力回避

## 7. ログ戦略拡張

### 7.1 認証ログ項目
- **ユーザー登録**: 成功・失敗ログ
- **ログイン試行**: 成功・失敗・無効トークンログ
- **認証エラー**: 不正アクセス試行ログ
- **トークン検証**: 検証成功・失敗ログ

### 7.2 セキュリティログ
- **不正アクセス**: 無効トークン・期限切れトークン
- **重複登録試行**: ユーザー名・メール重複試行
- **パスワード試行**: 不正パスワード試行回数

## 8. エラーハンドリング拡張

### 8.1 認証エラー
- **401 Unauthorized**: 無効な認証情報
- **403 Forbidden**: 非アクティブユーザー
- **400 Bad Request**: 重複登録・無効入力
- **500 Internal Server Error**: 認証システム内部エラー

### 8.2 データベースエラー
- **接続エラー**: データベース接続失敗
- **制約違反**: ユニーク制約違反
- **トランザクションエラー**: データベーストランザクション失敗

## 9. パフォーマンス考慮事項

### 9.1 認証最適化
- **トークン検証**: 効率的なJWT検証
- **データベースクエリ**: インデックス最適化
- **セッション管理**: 適切なデータベースセッション管理
- **キャッシュ戦略**: ユーザー情報キャッシュ検討

### 9.2 監視項目拡張
- **認証レスポンス時間**: ログイン・トークン検証時間
- **データベース接続**: 接続プール使用率
- **認証成功率**: 認証成功・失敗率
- **ユーザーアクティビティ**: アクティブユーザー数

## 10. デプロイメント拡張

### 10.1 本番環境要件追加
- **データベース**: PostgreSQL推奨（本番環境）
- **JWT秘密鍵**: 強力な秘密鍵生成・管理
- **HTTPS**: SSL/TLS証明書設定
- **データベースマイグレーション**: Alembicマイグレーション実行

### 10.2 起動コマンド拡張
```bash
# データベースマイグレーション実行
alembic upgrade head

# アプリケーション起動
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

## 11. 設計上の利点

### 11.1 既存システム統合
- **最小限の変更**: 既存コードへの影響最小化
- **一貫性**: 既存のFastAPIパターン踏襲
- **拡張性**: 将来的な機能拡張への対応
- **保守性**: 明確な責任分離とモジュール化

### 11.2 セキュリティ向上
- **業界標準**: JWT・bcryptによる標準的セキュリティ
- **認証必須**: 重要APIの認証保護
- **監査ログ**: 包括的なセキュリティログ
- **設定分離**: 機密情報の適切な分離

## 12. 今後の拡張予定

### 12.1 認証機能拡張
- **ロールベースアクセス制御**: 管理者・一般ユーザー権限
- **OAuth2統合**: Google・Microsoft認証連携
- **多要素認証**: SMS・メール認証追加
- **パスワードリセット**: メール経由パスワードリセット

### 12.2 ユーザー管理拡張
- **ユーザープロファイル**: 詳細プロファイル管理
- **組織管理**: 組織・チーム機能
- **使用量制限**: APIレート制限・使用量管理
- **監査ログ**: ユーザーアクティビティ詳細ログ

## 13. テスト戦略

### 13.1 単体テスト
- **認証ユーティリティ**: パスワードハッシュ・JWT生成検証
- **データベースモデル**: Userモデル操作テスト
- **依存関係**: 認証依存関係テスト

### 13.2 統合テスト
- **認証フロー**: 登録→ログイン→API呼び出しフロー
- **エラーハンドリング**: 各種エラーケーステスト
- **セキュリティ**: 不正アクセス・無効トークンテスト

### 13.3 E2Eテスト
- **API全体**: 認証付きAPI全体フローテスト
- **ブラウザテスト**: フロントエンド統合テスト（将来）
- **負荷テスト**: 認証システム負荷テスト

## 14. 依存関係追加

### 14.1 requirements.txt 追加項目
```txt
# 既存依存関係
fastapi
uvicorn
pydantic
pydantic-settings
python-dotenv
openai
python-multipart

# 認証システム新規依存関係
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
sqlalchemy==2.0.23
alembic==1.13.1
email-validator==2.1.0
```

---

**作成日**: 2025年7月15日  
**作成者**: Devin AI  
**バージョン**: 1.0  
**対象ブランチ**: main_okawa_20250714  
**実装対象**: ログイン認証システム構築（構築）
