# データベース設計書 - トランスクリプト議事録生成システム

## 1. 文書情報

| 項目 | 内容 |
|------|------|
| 文書名 | データベース設計書 |
| バージョン | 1.0 |
| 作成日 | 2025年7月24日 |
| 作成者 | AI Assistant |
| 基準文書 | 実装計画書01.md, システム設計書.md, API設計書.md |

## 2. データベース概要

### 2.1 データベース基本情報

| 項目 | 内容 |
|------|------|
| データベース名 | minutes_db |
| DBMS | PostgreSQL 15+ / SQLite 3.x |
| 文字エンコーディング | UTF-8 |
| タイムゾーン | UTC |
| ORM | SQLAlchemy 2.0+ |

### 2.2 設計方針

#### 2.2.1 基本原則
- **正規化**: 第3正規形まで正規化
- **パフォーマンス**: 適切なインデックス設計
- **拡張性**: 将来の機能拡張を考慮した設計
- **セキュリティ**: 個人情報保護とアクセス制御

#### 2.2.2 命名規則
- **テーブル名**: 複数形、スネークケース（例: `users`, `meeting_minutes`）
- **カラム名**: スネークケース（例: `user_id`, `created_at`）
- **インデックス名**: `idx_テーブル名_カラム名`
- **外部キー名**: `fk_テーブル名_参照テーブル名`

### 2.3 現在の実装状況

#### 2.3.1 Phase 1（現在実装済み）
- **データ永続化**: メモリ内データ管理（ファイルベース）
- **ユーザー管理**: 簡易ユーザーストア
- **議事録生成**: 一時的なレスポンス生成

#### 2.3.2 Phase 2（実装予定）
- **PostgreSQL/SQLite**: 本格的なデータベース統合
- **ユーザー認証**: JWT トークンベース認証
- **議事録履歴**: 永続的な議事録保存・管理

## 3. 論理データモデル

### 3.1 エンティティ関係図（ER図）

```
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│     Users       │       │    Meetings     │       │ MeetingMinutes  │
├─────────────────┤       ├─────────────────┤       ├─────────────────┤
│ id (PK)         │◄──────┤ user_id (FK)    │◄──────┤ meeting_id (FK) │
│ username        │       │ id (PK)         │       │ id (PK)         │
│ email           │       │ title           │       │ content         │
│ hashed_password │       │ description     │       │ summary         │
│ is_active       │       │ scheduled_at    │       │ action_items    │
│ created_at      │       │ duration        │       │ created_at      │
│ updated_at      │       │ participants    │       │ updated_at      │
└─────────────────┘       │ transcript      │       │ version         │
                          │ created_at      │       └─────────────────┘
                          │ updated_at      │
                          └─────────────────┘
                                    │
                                    ▼
                          ┌─────────────────┐
                          │ MeetingParticipants │
                          ├─────────────────┤
                          │ id (PK)         │
                          │ meeting_id (FK) │
                          │ user_id (FK)    │
                          │ role            │
                          │ joined_at       │
                          │ left_at         │
                          └─────────────────┘
```

### 3.2 エンティティ詳細

#### 3.2.1 Users（ユーザー）
```python
class User(Base):
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    username: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
    email: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now(), onupdate=func.now())
    
    # リレーション
    meetings: Mapped[List["Meeting"]] = relationship("Meeting", back_populates="user")
    participations: Mapped[List["MeetingParticipant"]] = relationship("MeetingParticipant", back_populates="user")
```

#### 3.2.2 Meetings（会議）
```python
class Meeting(Base):
    __tablename__ = "meetings"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id"), nullable=False)
    title: Mapped[str] = mapped_column(String(200), nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text)
    scheduled_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    duration: Mapped[Optional[int]] = mapped_column(Integer)  # 分単位
    transcript: Mapped[Optional[str]] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now(), onupdate=func.now())
    
    # リレーション
    user: Mapped["User"] = relationship("User", back_populates="meetings")
    minutes: Mapped[List["MeetingMinutes"]] = relationship("MeetingMinutes", back_populates="meeting")
    participants: Mapped[List["MeetingParticipant"]] = relationship("MeetingParticipant", back_populates="meeting")
```

#### 3.2.3 MeetingMinutes（議事録）
```python
class MeetingMinutes(Base):
    __tablename__ = "meeting_minutes"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    meeting_id: Mapped[int] = mapped_column(Integer, ForeignKey("meetings.id"), nullable=False)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    summary: Mapped[Optional[str]] = mapped_column(Text)
    action_items: Mapped[Optional[str]] = mapped_column(JSON)  # JSON形式でアクションアイテム保存
    version: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now(), onupdate=func.now())
    
    # リレーション
    meeting: Mapped["Meeting"] = relationship("Meeting", back_populates="minutes")
```

#### 3.2.4 MeetingParticipants（会議参加者）
```python
class MeetingParticipant(Base):
    __tablename__ = "meeting_participants"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    meeting_id: Mapped[int] = mapped_column(Integer, ForeignKey("meetings.id"), nullable=False)
    user_id: Mapped[Optional[int]] = mapped_column(Integer, ForeignKey("users.id"))  # 外部参加者の場合はNULL
    name: Mapped[str] = mapped_column(String(100), nullable=False)  # 外部参加者名
    email: Mapped[Optional[str]] = mapped_column(String(255))
    role: Mapped[str] = mapped_column(String(50), default="participant")  # host, participant, observer
    joined_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    left_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    
    # リレーション
    meeting: Mapped["Meeting"] = relationship("Meeting", back_populates="participants")
    user: Mapped[Optional["User"]] = relationship("User", back_populates="participations")
```

## 4. 物理データモデル

### 4.1 テーブル定義

#### 4.1.1 users テーブル
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    hashed_password VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_is_active ON users(is_active);
```

#### 4.1.2 meetings テーブル
```sql
CREATE TABLE meetings (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    scheduled_at TIMESTAMP WITH TIME ZONE,
    duration INTEGER,
    transcript TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_meetings_user_id ON meetings(user_id);
CREATE INDEX idx_meetings_scheduled_at ON meetings(scheduled_at);
CREATE INDEX idx_meetings_created_at ON meetings(created_at);
CREATE INDEX idx_meetings_title ON meetings USING gin(to_tsvector('japanese', title));
```

#### 4.1.3 meeting_minutes テーブル
```sql
CREATE TABLE meeting_minutes (
    id SERIAL PRIMARY KEY,
    meeting_id INTEGER NOT NULL REFERENCES meetings(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    summary TEXT,
    action_items JSONB,
    version INTEGER DEFAULT 1 NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_meeting_minutes_meeting_id ON meeting_minutes(meeting_id);
CREATE INDEX idx_meeting_minutes_version ON meeting_minutes(meeting_id, version);
CREATE INDEX idx_meeting_minutes_created_at ON meeting_minutes(created_at);
CREATE INDEX idx_meeting_minutes_content ON meeting_minutes USING gin(to_tsvector('japanese', content));
CREATE INDEX idx_meeting_minutes_action_items ON meeting_minutes USING gin(action_items);
```

#### 4.1.4 meeting_participants テーブル
```sql
CREATE TABLE meeting_participants (
    id SERIAL PRIMARY KEY,
    meeting_id INTEGER NOT NULL REFERENCES meetings(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255),
    role VARCHAR(50) DEFAULT 'participant',
    joined_at TIMESTAMP WITH TIME ZONE,
    left_at TIMESTAMP WITH TIME ZONE
);

-- インデックス
CREATE INDEX idx_meeting_participants_meeting_id ON meeting_participants(meeting_id);
CREATE INDEX idx_meeting_participants_user_id ON meeting_participants(user_id);
CREATE INDEX idx_meeting_participants_role ON meeting_participants(role);
```

### 4.2 制約定義

#### 4.2.1 CHECK制約
```sql
-- users テーブル
ALTER TABLE users ADD CONSTRAINT chk_users_username_length 
    CHECK (char_length(username) >= 3);
ALTER TABLE users ADD CONSTRAINT chk_users_email_format 
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- meetings テーブル
ALTER TABLE meetings ADD CONSTRAINT chk_meetings_title_length 
    CHECK (char_length(title) >= 1);
ALTER TABLE meetings ADD CONSTRAINT chk_meetings_duration_positive 
    CHECK (duration IS NULL OR duration > 0);

-- meeting_minutes テーブル
ALTER TABLE meeting_minutes ADD CONSTRAINT chk_meeting_minutes_content_length 
    CHECK (char_length(content) >= 10);
ALTER TABLE meeting_minutes ADD CONSTRAINT chk_meeting_minutes_version_positive 
    CHECK (version > 0);

-- meeting_participants テーブル
ALTER TABLE meeting_participants ADD CONSTRAINT chk_meeting_participants_role 
    CHECK (role IN ('host', 'participant', 'observer'));
ALTER TABLE meeting_participants ADD CONSTRAINT chk_meeting_participants_time_order 
    CHECK (left_at IS NULL OR joined_at IS NULL OR left_at >= joined_at);
```

#### 4.2.2 UNIQUE制約
```sql
-- 会議ごとの議事録バージョンの一意性
ALTER TABLE meeting_minutes ADD CONSTRAINT uk_meeting_minutes_meeting_version 
    UNIQUE (meeting_id, version);

-- 会議ごとのユーザー参加の一意性（同じユーザーが複数回参加することを防ぐ）
ALTER TABLE meeting_participants ADD CONSTRAINT uk_meeting_participants_meeting_user 
    UNIQUE (meeting_id, user_id);
```

## 5. データ型とサイズ設計

### 5.1 文字列型サイズ設計

| カラム | データ型 | サイズ | 理由 |
|--------|----------|--------|------|
| username | VARCHAR(50) | 50文字 | 一般的なユーザー名の長さ |
| email | VARCHAR(255) | 255文字 | RFC 5321準拠 |
| hashed_password | VARCHAR(255) | 255文字 | bcrypt等のハッシュ値 |
| meeting.title | VARCHAR(200) | 200文字 | 会議タイトルの適切な長さ |
| participant.name | VARCHAR(100) | 100文字 | 参加者名の適切な長さ |
| participant.role | VARCHAR(50) | 50文字 | ロール名の適切な長さ |

### 5.2 テキスト型設計

| カラム | データ型 | 理由 |
|--------|----------|------|
| meeting.description | TEXT | 可変長の会議説明 |
| meeting.transcript | TEXT | 大容量のトランスクリプト |
| minutes.content | TEXT | 大容量の議事録内容 |
| minutes.summary | TEXT | 可変長の要約 |

### 5.3 JSON型設計

#### 5.3.1 action_items カラム構造
```json
{
  "items": [
    {
      "id": "action_001",
      "description": "詳細計画書の作成",
      "assignee": "田中",
      "due_date": "2025-07-31",
      "status": "pending",
      "priority": "high",
      "created_at": "2025-07-24T10:00:00Z"
    },
    {
      "id": "action_002", 
      "description": "予算申請の提出",
      "assignee": "佐藤",
      "due_date": "2025-07-28",
      "status": "in_progress",
      "priority": "medium",
      "created_at": "2025-07-24T10:00:00Z"
    }
  ],
  "metadata": {
    "total_count": 2,
    "pending_count": 1,
    "completed_count": 0
  }
}
```

## 6. インデックス設計

### 6.1 主要クエリパターン

#### 6.1.1 ユーザー関連クエリ
```sql
-- ユーザー認証
SELECT * FROM users WHERE username = ? AND is_active = true;
SELECT * FROM users WHERE email = ? AND is_active = true;

-- 対応インデックス
CREATE INDEX idx_users_username_active ON users(username, is_active);
CREATE INDEX idx_users_email_active ON users(email, is_active);
```

#### 6.1.2 会議関連クエリ
```sql
-- ユーザーの会議一覧
SELECT * FROM meetings WHERE user_id = ? ORDER BY scheduled_at DESC;

-- 期間指定での会議検索
SELECT * FROM meetings WHERE scheduled_at BETWEEN ? AND ?;

-- 会議タイトル検索
SELECT * FROM meetings WHERE to_tsvector('japanese', title) @@ plainto_tsquery('japanese', ?);

-- 対応インデックス
CREATE INDEX idx_meetings_user_scheduled ON meetings(user_id, scheduled_at DESC);
CREATE INDEX idx_meetings_scheduled_range ON meetings(scheduled_at);
CREATE INDEX idx_meetings_title_search ON meetings USING gin(to_tsvector('japanese', title));
```

#### 6.1.3 議事録関連クエリ
```sql
-- 会議の最新議事録
SELECT * FROM meeting_minutes WHERE meeting_id = ? ORDER BY version DESC LIMIT 1;

-- 議事録内容検索
SELECT * FROM meeting_minutes WHERE to_tsvector('japanese', content) @@ plainto_tsquery('japanese', ?);

-- アクションアイテム検索
SELECT * FROM meeting_minutes WHERE action_items @> '{"items": [{"status": "pending"}]}';

-- 対応インデックス
CREATE INDEX idx_meeting_minutes_meeting_version_desc ON meeting_minutes(meeting_id, version DESC);
CREATE INDEX idx_meeting_minutes_content_search ON meeting_minutes USING gin(to_tsvector('japanese', content));
CREATE INDEX idx_meeting_minutes_action_status ON meeting_minutes USING gin(action_items);
```

### 6.2 複合インデックス設計

#### 6.2.1 パフォーマンス重視の複合インデックス
```sql
-- ユーザーの最新会議取得用
CREATE INDEX idx_meetings_user_scheduled_desc ON meetings(user_id, scheduled_at DESC);

-- 会議の最新議事録取得用
CREATE INDEX idx_minutes_meeting_version_desc ON meeting_minutes(meeting_id, version DESC);

-- アクティブユーザーの認証用
CREATE INDEX idx_users_credentials ON users(username, hashed_password) WHERE is_active = true;
```

#### 6.2.2 部分インデックス
```sql
-- アクティブユーザーのみ
CREATE INDEX idx_users_active_username ON users(username) WHERE is_active = true;
CREATE INDEX idx_users_active_email ON users(email) WHERE is_active = true;

-- 未来の会議のみ
CREATE INDEX idx_meetings_future ON meetings(scheduled_at) WHERE scheduled_at > CURRENT_TIMESTAMP;

-- 完了していないアクションアイテム
CREATE INDEX idx_minutes_pending_actions ON meeting_minutes(meeting_id) 
WHERE action_items @> '{"items": [{"status": "pending"}]}';
```

## 7. データ移行設計

### 7.1 初期データ移行

#### 7.1.1 マスターデータ
```sql
-- デフォルト管理者ユーザー
INSERT INTO users (username, email, hashed_password, is_active) VALUES
('admin', 'admin@example.com', '$2b$12$...', true);

-- サンプル会議データ（開発環境用）
INSERT INTO meetings (user_id, title, description, scheduled_at) VALUES
(1, 'システム設計会議', 'トランスクリプト議事録生成システムの設計について', '2025-07-25 10:00:00+00');
```

#### 7.1.2 既存データ移行スクリプト
```python
# 既存のメモリ内データからの移行
async def migrate_existing_data():
    # ユーザーデータ移行
    for user_data in existing_users:
        user = User(
            username=user_data['username'],
            email=user_data['email'],
            hashed_password=user_data['hashed_password']
        )
        session.add(user)
    
    # 会議データ移行
    for meeting_data in existing_meetings:
        meeting = Meeting(
            user_id=meeting_data['user_id'],
            title=meeting_data['title'],
            transcript=meeting_data['transcript']
        )
        session.add(meeting)
    
    await session.commit()
```

### 7.2 バージョン管理

#### 7.2.1 Alembic設定
```python
# alembic/env.py
from src.models import Base
target_metadata = Base.metadata

def run_migrations_online():
    configuration = config.get_section(config.config_ini_section)
    configuration['sqlalchemy.url'] = get_database_url()
    
    connectable = engine_from_config(
        configuration,
        prefix='sqlalchemy.',
        poolclass=pool.NullPool,
    )
    
    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )
        
        with context.begin_transaction():
            context.run_migrations()
```

#### 7.2.2 マイグレーションファイル例
```python
# alembic/versions/001_initial_schema.py
"""Initial schema

Revision ID: 001
Revises: 
Create Date: 2025-07-24 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # users テーブル作成
    op.create_table('users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=255), nullable=False),
        sa.Column('hashed_password', sa.String(length=255), nullable=False),
        sa.Column('is_active', sa.Boolean(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email'),
        sa.UniqueConstraint('username')
    )
    
    # meetings テーブル作成
    op.create_table('meetings',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.Integer(), nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('scheduled_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('duration', sa.Integer(), nullable=True),
        sa.Column('transcript', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id')
    )
    
    # その他のテーブル作成...

def downgrade():
    op.drop_table('meeting_participants')
    op.drop_table('meeting_minutes')
    op.drop_table('meetings')
    op.drop_table('users')
```

## 8. セキュリティ設計

### 8.1 データ暗号化

#### 8.1.1 保存時暗号化
```sql
-- 機密データの暗号化（PostgreSQL）
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- パスワードハッシュ化
UPDATE users SET hashed_password = crypt(plain_password, gen_salt('bf', 12));

-- 機密データ暗号化
ALTER TABLE meetings ADD COLUMN encrypted_transcript BYTEA;
UPDATE meetings SET encrypted_transcript = pgp_sym_encrypt(transcript, 'encryption_key');
```

#### 8.1.2 アプリケーションレベル暗号化
```python
from cryptography.fernet import Fernet

class EncryptionService:
    def __init__(self, key: str):
        self.cipher = Fernet(key.encode())
    
    def encrypt_sensitive_data(self, data: str) -> str:
        return self.cipher.encrypt(data.encode()).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        return self.cipher.decrypt(encrypted_data.encode()).decode()
```

### 8.2 アクセス制御

#### 8.2.1 行レベルセキュリティ（RLS）
```sql
-- PostgreSQL Row Level Security
ALTER TABLE meetings ENABLE ROW LEVEL SECURITY;
ALTER TABLE meeting_minutes ENABLE ROW LEVEL SECURITY;

-- ユーザーは自分の会議のみアクセス可能
CREATE POLICY user_meetings_policy ON meetings
    FOR ALL TO application_user
    USING (user_id = current_setting('app.current_user_id')::INTEGER);

-- 議事録も同様の制御
CREATE POLICY user_minutes_policy ON meeting_minutes
    FOR ALL TO application_user
    USING (meeting_id IN (
        SELECT id FROM meetings 
        WHERE user_id = current_setting('app.current_user_id')::INTEGER
    ));
```

#### 8.2.2 データベースロール設計
```sql
-- アプリケーション用ロール
CREATE ROLE app_user LOGIN PASSWORD 'secure_password';
GRANT CONNECT ON DATABASE minutes_db TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO app_user;

-- 読み取り専用ロール（レポート用）
CREATE ROLE app_readonly LOGIN PASSWORD 'readonly_password';
GRANT CONNECT ON DATABASE minutes_db TO app_readonly;
GRANT USAGE ON SCHEMA public TO app_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_readonly;

-- 管理者ロール
CREATE ROLE app_admin LOGIN PASSWORD 'admin_password';
GRANT ALL PRIVILEGES ON DATABASE minutes_db TO app_admin;
```

## 9. バックアップ・復旧設計

### 9.1 バックアップ戦略

#### 9.1.1 定期バックアップ
```bash
#!/bin/bash
# daily_backup.sh

DB_NAME="minutes_db"
BACKUP_DIR="/backup/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)

# フルバックアップ
pg_dump -h localhost -U app_user -d $DB_NAME -f "$BACKUP_DIR/full_backup_$DATE.sql"

# 圧縮
gzip "$BACKUP_DIR/full_backup_$DATE.sql"

# 古いバックアップの削除（30日以上）
find $BACKUP_DIR -name "full_backup_*.sql.gz" -mtime +30 -delete
```

#### 9.1.2 増分バックアップ（PostgreSQL WAL）
```bash
# WAL アーカイブ設定
# postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'cp %p /backup/wal_archive/%f'
max_wal_senders = 3
```

### 9.2 災害復旧

#### 9.2.1 復旧手順
```bash
# 1. データベース停止
sudo systemctl stop postgresql

# 2. データディレクトリのバックアップ
sudo mv /var/lib/postgresql/15/main /var/lib/postgresql/15/main.backup

# 3. ベースバックアップからの復元
sudo -u postgres pg_basebackup -h backup_server -D /var/lib/postgresql/15/main -U replication

# 4. WAL ファイルの復元設定
echo "restore_command = 'cp /backup/wal_archive/%f %p'" > /var/lib/postgresql/15/main/recovery.conf

# 5. データベース起動
sudo systemctl start postgresql
```

#### 9.2.2 Point-in-Time Recovery
```sql
-- 特定時点への復旧
SELECT pg_create_restore_point('before_data_corruption');

-- recovery.conf 設定例
restore_command = 'cp /backup/wal_archive/%f %p'
recovery_target_time = '2025-07-24 14:30:00'
recovery_target_action = 'promote'
```

## 10. パフォーマンス最適化

### 10.1 クエリ最適化

#### 10.1.1 実行計画の分析
```sql
-- 重要クエリの実行計画確認
EXPLAIN (ANALYZE, BUFFERS) 
SELECT m.*, mm.content 
FROM meetings m 
LEFT JOIN meeting_minutes mm ON m.id = mm.meeting_id 
WHERE m.user_id = 1 
ORDER BY m.scheduled_at DESC 
LIMIT 10;

-- インデックス使用状況の確認
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;
```

#### 10.1.2 統計情報の更新
```sql
-- 統計情報の手動更新
ANALYZE users;
ANALYZE meetings;
ANALYZE meeting_minutes;

-- 自動統計更新の設定
ALTER TABLE meetings SET (autovacuum_analyze_scale_factor = 0.1);
ALTER TABLE meeting_minutes SET (autovacuum_analyze_scale_factor = 0.1);
```

### 10.2 接続プール設定

#### 10.2.1 SQLAlchemy 接続プール
```python
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=20,          # 基本接続数
    max_overflow=30,       # 最大追加接続数
    pool_pre_ping=True,    # 接続の事前確認
    pool_recycle=3600,     # 接続の再利用時間（秒）
    echo=False             # SQLログ出力（本番環境では False）
)
```

#### 10.2.2 PgBouncer設定
```ini
# pgbouncer.ini
[databases]
minutes_db = host=localhost port=5432 dbname=minutes_db

[pgbouncer]
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 25
max_db_connections = 50
```

## 11. 監視・メトリクス

### 11.1 データベース監視

#### 11.1.1 重要メトリクス
```sql
-- 接続数監視
SELECT count(*) as active_connections 
FROM pg_stat_activity 
WHERE state = 'active';

-- ロック監視
SELECT blocked_locks.pid AS blocked_pid,
       blocked_activity.usename AS blocked_user,
       blocking_locks.pid AS blocking_pid,
       blocking_activity.usename AS blocking_user,
       blocked_activity.query AS blocked_statement,
       blocking_activity.query AS current_statement_in_blocking_process
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- テーブルサイズ監視
SELECT schemaname, tablename, 
       pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables 
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

#### 11.1.2 アラート設定
```python
# データベース監視アラート
class DatabaseMonitor:
    def check_connection_count(self):
        result = session.execute(text("SELECT count(*) FROM pg_stat_activity"))
        count = result.scalar()
        if count > 80:  # 80%閾値
            self.send_alert(f"High connection count: {count}")
    
    def check_slow_queries(self):
        result = session.execute(text("""
            SELECT query, query_start, now() - query_start as duration
            FROM pg_stat_activity 
            WHERE state = 'active' 
            AND now() - query_start > interval '30 seconds'
        """))
        
        for row in result:
            self.send_alert(f"Slow query detected: {row.duration}")
```

## 12. 将来拡張計画

### 12.1 Phase 3: 高度な機能

#### 12.1.1 全文検索強化
```sql
-- 日本語全文検索の強化
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- トライグラム検索インデックス
CREATE INDEX idx_meetings_title_trgm ON meetings USING gin(title gin_trgm_ops);
CREATE INDEX idx_minutes_content_trgm ON meeting_minutes USING gin(content gin_trgm_ops);

-- 複合検索ビュー
CREATE VIEW search_view AS
SELECT 
    m.id as meeting_id,
    m.title,
    m.description,
    mm.content,
    mm.summary,
    to_tsvector('japanese', m.title || ' ' || COALESCE(m.description, '') || ' ' || COALESCE(mm.content, '')) as search_vector
FROM meetings m
LEFT JOIN meeting_minutes mm ON m.id = mm.meeting_id;

CREATE INDEX idx_search_view_vector ON search_view USING gin(search_vector);
```

#### 12.1.2 パーティショニング
```sql
-- 日付ベースパーティショニング（大量データ対応）
CREATE TABLE meetings_partitioned (
    LIKE meetings INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- 月次パーティション作成
CREATE TABLE meetings_2025_07 PARTITION OF meetings_partitioned
    FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');

CREATE TABLE meetings_2025_08 PARTITION OF meetings_partitioned
    FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');
```

### 12.2 Phase 4: マルチテナント対応

#### 12.2.1 テナント分離設計
```sql
-- テナントテーブル追加
CREATE TABLE tenants (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    subdomain VARCHAR(50) UNIQUE NOT NULL,
    settings JSONB,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ユーザーテーブルにテナント追加
ALTER TABLE users ADD COLUMN tenant_id INTEGER REFERENCES tenants(id);

-- テナント別RLS
CREATE POLICY tenant_isolation_policy ON users
    FOR ALL TO application_user
    USING (tenant_id = current_setting('app.current_tenant_id')::INTEGER);
```

#### 12.2.2 スキーマ分離アプローチ
```sql
-- テナント別スキーマ作成
CREATE SCHEMA tenant_001;
CREATE SCHEMA tenant_002;

-- 各スキーマにテーブル作成
CREATE TABLE tenant_001.users (LIKE public.users INCLUDING ALL);
CREATE TABLE tenant_001.meetings (LIKE public.meetings INCLUDING ALL);
```

---

**文書管理情報**
- **最終更新**: 2025年7月24日
- **レビュー状況**: 初版作成完了
- **承認者**: 未定
- **次回レビュー**: 実装完了後
- **関連文書**: システム設計書.md, API設計書.md
